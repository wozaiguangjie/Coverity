<?xml version="1.0" encoding="UTF-8"?>
<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  xsi:noNamespaceSchemaLocation="messagecollection.xsd">

  <!--
  **********************************************************************
  Plugin information
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription>Default FindBugs plugin</ShortDescription>
    <Details>
<![CDATA[
<p>
This plugin contains all of the standard FindBugs detectors.
</p>
]]>
    </Details>
  </Plugin>

  <!--
  **********************************************************************
  Categories (replacing the BugCategoryDescriptions.properties file)
  **********************************************************************
   -->

  <BugCategory category="CORRECTNESS">
    <Description>Correctness</Description>
    <Abbreviation>C</Abbreviation>
    <Details>Probable bug - an apparent coding mistake
            resulting in code that was probably not what the
            developer intended. We strive for a low false positive rate.</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>Bogus random noise</Description>
    <Abbreviation>N</Abbreviation>
    <Details>Bogus random noise: intended to be useful
	as a control in data mining experiments, not in finding actual bugs in software
            </Details>
  </BugCategory>

  <BugCategory category="SECURITY">
    <Description>Security</Description>
    <Abbreviation>S</Abbreviation>
    <Details>A use of untrusted input in a way that could create a remotely exploitable security vulnerability.
	</Details>
  </BugCategory>

  <BugCategory category="BAD_PRACTICE">
    <Description>Bad practice</Description>
    <Abbreviation>B</Abbreviation>
    <Details>Violations of recommended and essential
            coding practice. Examples include hash code and equals
            problems, cloneable idiom, dropped exceptions,  
            Serializable problems, and misuse of finalize.
            We strive to make this analysis accurate,
            although some groups may
            not care about some of the bad practices.</Details>
  </BugCategory>

  <BugCategory category="STYLE">
    <Description>Dodgy</Description>
    <Abbreviation>D</Abbreviation>
    <Details>code that is confusing, anomalous, or
            written in a way that leads itself to errors.
            Examples include dead local stores, switch fall through,
            unconfirmed casts, and redundant null check of value
            known to be null.
            More false positives accepted.
            In previous versions of FindBugs, this category was known as Style.
</Details>
  </BugCategory>

  <BugCategory category="PERFORMANCE">
    <Description>Performance</Description>
    <Abbreviation>P</Abbreviation>
    <Details>code that is not necessarily incorrect but may be inefficient</Details>
  </BugCategory>

  <BugCategory category="MALICIOUS_CODE">
    <Description>Malicious code vulnerability</Description>
    <Abbreviation>V</Abbreviation>
    <Details>code that is vulnerable to attacks from untrusted code</Details>
  </BugCategory>

  <BugCategory category="MT_CORRECTNESS">
    <Description>Multithreaded correctness</Description>
    <Abbreviation>M</Abbreviation>
    <Details>code flaws having to do with threads, locks, and volatiles</Details>
  </BugCategory>

  <BugCategory category="I18N">
    <Description>Internationalization</Description>
    <Abbreviation>I</Abbreviation>
    <Details>code flaws having to do with internationalization and locale</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>

  <BugCategory category="EXPERIMENTAL">
    <Description>Experimental</Description>
    <Abbreviation>X</Abbreviation>
    <Details>Experimental and not fully vetted bug patterns</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>


  <!--
  **********************************************************************
  Detectors
  **********************************************************************
   -->

 <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
     <Details>
<![CDATA[
<p> This detector finds inconsistencies between type qualifiers directly
applied to method parameters and uses of those method parameters. </p>
]]>
     </Details>
   </Detector>


	<Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
     <Details>
<![CDATA[
<p> This detector looks for synchronization on a shared builtin constant (such as a String).</p>
]]>
     </Details>
   </Detector>

	<Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
     <Details>
<![CDATA[
<p> This detector looks for a field that is synchronized on and then null checked.</p>
]]>
     </Details>
   </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[
<p> Looks for violations of the rules for classes annotated as net.jcip.annotations.Immutable.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[
<p> Looks for problems with arising from Java 1.5 var args.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[
<p> Record annotations from the net.jcip.annotations package.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[
<p> Note the type qualifiers relevant to analyzing a method.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[
      <p>Builds the interprocedural call graph.</p>
      ]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
	  <Details>
		  <![CDATA[
		  <p>Builds the database of obligation types and methods used by the FindUnsatisfiedObligation detector.
		  ]]>
	  </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[
<p> Suppresses warnings based on use of the edu.umd.cs.findbugs.annotations.NoteSuppressWarnings annotation.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[
<p> Records annotation retention.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[
        <p>Records synthetic classes, methods, fields, etc.</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[
<p> Builds of database of all methods defined in analyzed classes, for use
by other detectors.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[
<p> Try to determine which classes have constant references to their .class objects.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[
<p> Builds of database of all methods invoked in analyzed classes, for use
by other detectors.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[
<p> Looks for potential confusion between inherited and outer methods.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValue">
    <Details>
<![CDATA[
<p> Looks for annotations to check return values of a method.
</p>
]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[
<p> Looks for annotations to check return values of a method.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[
<p> Look for code that synchronizes on the results of getClass rather than on class 
literals.
</p>
]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
   <Details>
      <![CDATA[
      <p>
	This detector produces summary information for what is stored 
	into fields.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
   <Details>
      <![CDATA[
      <p>
      Looks for @NonNull annotations on methods, fields, and parameters.
      These can be used by the FindNullDeref detector to generate warnings
      when a possibly-null value is used in a context where only
      non-null values should be used.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
   <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
      dereference parameters unconditionally.  This information is used in
      a later analysis pass to find call sites where null values may
      be passed to those methods.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
   <Details>
      <![CDATA[
      <p>
      Analyze all methods in the application to determine which
	methods always return nonnull values.
      </p>
      ]]>
   </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[
<p> Looks for methods with Boolean return type that return explicit null values.</p>

]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[
<p> Looks for cases where the return value of a function is discarded
after being checked for non-null.  </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[
<p> Looks for uses of this.getClass().getResource(...), which can give
unexpected results if the class is extended by a class in
another package. </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[
<p> Looks for an infinite recursive loop. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[
<p> Looks for an infinite loop. </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop2">
   <Details>
<![CDATA[
<p>Looks for an infinite recursive loop. It is a slow detector.</p>
]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[
<p> Looks for bug patterns in the usage of volatile fields. </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[
<p> This looks for creation of empty zip file entries. It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[
<p> This detector looks for anonymous inner classes that define methods
that are probably intended to but do not override methods in a superclass.
</p>
]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[
<p>Checks that fields and methods don't use the name assert or enum as they are keywords in Java 5.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[
<p> The equals and hashCode method on <code>java.net.URL</code> resolve
the domain name. As a result, these operations can be very expensive, and this
detector looks for places where those methods might be invoked.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
  	<Details>
<![CDATA[
<p> This detector looks for finalizers that null out fields of a class.  
This does not help the garbage collector in any way, the nulling out of fields has no effect.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[
<p> This detector looks for obvious/blatant cases of cross site scripting vulnerabilities.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[
<p> This detector looks for code containing repeated conditional tests, such as (x == 5 || x == 5). 
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods that are unsupported.
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[
<p> Checks for incorrect format strings.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[
<p> Checks for equals methods that check for their operand being an instance of a class 
that is not compatible with the class defining the equals method.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[
<p> This detector finds code that behaves differently under OpenJDK 1.6, where
weak references are used to hold onto Loggers.
</p>
]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[
<p> This detector generates a random signal: warnings that are just based on
hash values of the operations performed by methods.
These warnings are bogus random noise, intended to be useful
        as a control in data mining experiments, not in finding actual bugs in software

 This detector is just a hook for testing new detectors.
Normally, this detector does nothing.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[
<p> Noisy detector for null dereferences. Intended to be used as a control in experiments
about the validity or predictive ability of warnings, not as a way to find problems in code.
</p>
]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[
<p> This detector looks for string constants that are duplicated across multiple classfiles.
</p>
]]>
    </Details>
  </Detector>



 <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[
<p> Look for code that should be executed inside doPrivileged blocks.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[
<p> Checks that all references call be resolved.  </p>
]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[
<p> This detector looks for switch statements containing fall through.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[
<p> This detector looks for places where a field is assigned
by reading the value of the same field.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where a value is compared with itself.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[
<p> This detector looks for places where a value is compared with itself.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[
<p> This detector looks for suspicious uses of non-short-circuiting
boolean operators (<code>|</code> and <code>&amp;</code> instead of
<code>||</code> and <code>&amp;&amp;</code>).</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[
<p> This detector looks for try-catch blocks that catch an IllegalMonitorStateException.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[
<p> This detector looks for uses of floating point math. It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
cloneable classes. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[
<p> This detector looks for violations of the idioms for writing
classes that implement <code>Comparator</code>. </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[
<p> This detector looks for code where an exception is caught,
but nothing is done to handle the exception.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[
<p> Looks for loads of values known to be null.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[
<p> This detector looks for bad arguments being passed to methods
(e.g., substring(0)).
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[
<p> This detector looks for calls to pointless methods,
such as the no-argument String constructor.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[
<p> Looks for calls to Number constructors with primitive arguments.
</p>                      
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck" >
    <Details>
<![CDATA[
<p> This detector looks for instances of double checked locking.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations" >
    <Details>
<![CDATA[
<p> This detector looks for calls to finalize() and other finalizer-related
issues.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch" >
    <Details>
<![CDATA[
<p> This detector looks for problems in the definition of the hashCode() and equals()
methods.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical" >
    <Details>
<![CDATA[
<p> Looks for equals methods that override equals methods in a superclass where the equivalence relationship might not be symmetrical.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify" >
    <Details>
<![CDATA[
<p> This detector looks for calls to notify() that don't seem
to modify mutable object state.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef" >
    <Details>
<![CDATA[
<p> This detector looks for methods that return mutable static data.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations" >
    <Details>
<![CDATA[
<p> This detector looks for calls to Thread.run().  It is a fast
detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop" >
    <Details>
<![CDATA[
<p> This detector looks for loops that spin reading from a field.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() with two (or more) locks held.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() not in a conditional or loop.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet" >
    <Details>
<![CDATA[
<p> This detector looks for reads of uninitialized fields in constructors.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet" >
    <Details>
<![CDATA[
<p> This detector looks for get and set methods where the get is unsynchronized
while the set is synchronized.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain" >
    <Details>
<![CDATA[
<p> This detector looks for potentially circular class initialization
dependencies.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms" >
    <Details>
<![CDATA[
<p> This iterator looks for problems in how Iterator classes are defined.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LockedFields" >
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest" >
    <Details>
<![CDATA[
<p> This detector looks for comparisons of String objects using the == or !=
operators.
 </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableLock" >
    <Details>
<![CDATA[
<p> This detector looks for synchronization on objects read from
modified fields.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField" >
    <Details>
<![CDATA[
<p> This detector looks for code that seems to be synchronizing on a field in order
to guard updates of that field.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields" >
    <Details>
<![CDATA[
<p> This detector looks for static fields that may be modified by
malicious code.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.Naming" >
    <Details>
<![CDATA[
<p> This detector looks for suspiciously-named methods.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked" >
    <Details>
<![CDATA[
<p> This detector looks for calls to InputStream.read() or InputStream.skip() where the
return value is ignored.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom" >
    <Details>
<![CDATA[
<p> This detector looks for potential problems in the implementation
of Serializable classes.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor" >
    <Details>
<![CDATA[
<p> This detector looks for constructors that start threads.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop" >
    <Details>
<![CDATA[
<p> This detector looks for incorrect for loops.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields" >
    <Details>
<![CDATA[
<p> This detector looks for fields whose value is never read.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop" >
    <Details>
<![CDATA[
<p> This detector looks for calls to wait() that are not in a loop.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck" >
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur.  It also looks for redundant comparisons of reference values against
null.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[
<p> This detector looks for places where a null pointer exception might
occur, and the use of non-short-circuit evaluation causes the usual techniques to fail.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[
<p> This detector looks for IO stream objects which do not escape the
method and do not appear to be closed on all paths out of the method.
It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[
<p> This detector looks for methods that return either arrays or an explicit null reference.
Returning a zero length array is generally preferred in this context to returning a null reference.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[
<p> This detector looks for control flow statements which have no effect.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[
<p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
locks which are acquired, but not released on all paths out of the method.&nbsp;
It is a moderately fast detector.&nbsp; Note that in order to use this
detector, you need to have the <code>java.util.concurrent</code> package
in the auxiliary classpath (or be analyzing the package itself).</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[
<p> This detector looks for places where two reference values are compared
with the == or != operator, and the class is of a type (such as <code>java.lang.String</code>)
where comparing reference values is generally an error.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[
<p> This detector looks for calls to wait(), notify(), or notifyAll()
which do not appear to be made on an object which is currently locked.&nbsp;
It is a moderately fast detector.&nbsp; <b>This detector is disabled because
it is still under development, and produces too many false positives.</b></p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock" >
    <Details>
<![CDATA[
<p> This detector looks for empty synchronized blocks.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2" >
    <Details>
<![CDATA[
<p> This detector looks for fields that are accessed in an inconsistent manner
with respect to locking.  It is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[
<p> This detector looks for self assignments of local variables.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[
<p> This detector looks for suspicious bitwise logical expressions.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[
<p> This detector looks for lazy field initialization where the
field is not volatile.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[
<p> This detector looks for ordinary synchronization performed
on JSR166 locks.  It is a moderately fast detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[
<p> This detector looks for private methods that are never called.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[
<p> This detector looks for String concatenation in loops using +.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[
<p> This detector looks for code that converts Collections to arrays
using the toArray() method that takes a prototype array, passing
an array argument which is zero-length.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[
<p> This detector looks for JUnit tests that are malformed.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[
<p> This detector looks for code that extends an Adapter class and overrides a Listener
method with the wrong signature. </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[
<p> This detector looks for calls to getXXX or setXXX methods of a result set where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[
<p> This detector looks for type checks using the instanceof operator where the determination
can be done statically. </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[
<p>
This detector looks for Applet constructors that call methods in the parent
Applet that rely on the Applet stub. Since this stub isn't initialized until just
before the init() method, these methods will fail in the constructor. 
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UseObjectEquals">
    <Details>
<![CDATA[
<p>
This detector looks calls to equals(java.lang.Object) on arrays, or final classes that do not
override the equals method in the Object class. This means that equals semantics is the same as
==, and probably a mistake.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[
<p>
This detector looks for calls to Thread.interrupted() from a non static context. If it is called from
Thread.currentThread().interrupted(), then it is just a useless exercise, just use Thread.interrupted().
However if it is called on an arbitrary thread object, it is most probably an error, as interrupted()
is always called on the current thread.
</p>
]]>
    </Details>
  </Detector>

<Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
<Details>
<![CDATA[
<p>
This detector uses data flow analysis to look for invocations of execute methods
on SQL statements in switch something other than a constant string is passed as an argument.
</p>
]]>
    </Details>
  </Detector>

<Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
<Details>
<![CDATA[
<p>
This detector looks for assignments to local variables that
are never subsequently read. It is a moderately fast detector.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[
<p> This detector looks for class level fields that are masked by
local fields defined in methods.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[
<p> This detector looks for accessing the value of a Map entry, using a key that was retrieved from
a keySet iterator. </p>
]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[
<p> This detector looks for code that creates objects based on classes that only define static methods.
</p>
]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
     <Details>
<![CDATA[
<p> This detector looks for catch clauses that catch Exception,
when no code in the block throws Exception. </p>
]]>
     </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
      <Details>
<![CDATA[
<p> Looks for floating point equality expressions. A fast detector. </p>
]]>
      </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[
<p>This detector looks for I/O streams and database resources that
are not cleaned up on all paths out of a method.  This is a slow detector.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[
<p>This detector looks for code that calls java.lang.Math static methods on constant values,
where the resultant value is a statically known constant. It is faster, and sometimes more
accurate, to use the constant instead.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[
<p>This detector looks circular dependencies among classes. </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[
<p>This detector looks for classes that declare they implement the same interface
as a super class. This is redundant, if a superclass implements an interface, so does
the subclass.</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[
<p>This detector looks for potential problems in implementing the Struts framework.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[
<p>This detector looks for public classes that synchronize and use wait(), notify() or notifyAll()
on <b>this</b>. This exposes a synchronization implementation as a public artifact of the class.
Clients of the class may use an instance of the class as it's own synchronizing object, and cause
havoc to the base implementation.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[
<p> This detector looks for calls to methods where the return value
is suspiciously ignored.  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[
<p>
This detector looks for places where the result of integer division is
cast to double. Often, what was meant was to cast the integer operands
to double and then perform the division.  
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast">
    <Details>
<![CDATA[
<p>
This detector looks for bad casts of object references.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[
<p>
This detector looks for bad casts of object references using data flow analysis.
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[
<p>
This detector looks for stores of non Serializable objects into HTTP sessions.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[
<p>
This detector looks for stores of non Serializable objects passed to the writeObject method of
an ObjectOutput.
</p>
]]>
    </Details>
  </Detector>




  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[
<p> This detector looks for regular expressions that have invalid syntax.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[
<p> This detector problems looks for miscellaneous small errors
mentioned by Joshua Bloch and Neal Gafter in
their work on Programming Puzzlers.
  </p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
   <Details>
      <![CDATA[
      <p>
         This detector looks for calls to Thread.sleep() made with
         a lock held.  It is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[
<p> This detector looks for if/else or switch statements that have the
same code for two branches, thus rendering the test useless. This often
is caused by copying and pasting the two branches, causing incorrect logic
for the one branch.</p><p></p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
   <Details>
<![CDATA[
<p> This detector looks for internal classes that write to member variables of the
owning class, when that member variable is private. In this case, a special compiler
generated accessor method needs to be used to write to this variable. Relaxing the
visibility to protected will allow the field to be directly written.</p>
<p></p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
   <Details>
<![CDATA[
<p> This detector looks for direct allocations of implementations of XML interfaces.
This ties the code to a specific implementation, rather than using the supplied
factory pattern to create these objects.</p>
<p></p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBadEqualsImplementation">
   <Details>
      <![CDATA[
      <p>
      This detector looks for equals(Object) method implementations which
      unconditionally dereference their parameter.  This violates the contract
      defined by java.lang.Object.equals(), which states that if the parameter
      is null, the method must return null.
      </p>
      <p>It is a slow detector.</p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
   <Details>
      <![CDATA[
      <p>
      This detector looks for subclasses that implement methods defined in the super
      class, that only pass the parameters untouched to the parent class method.
      These methods can just be removed.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
   <Details>
      <![CDATA[
      <p>
      This detector for final classes that declare protected members. As this
      class can not be derived from, the use of protected access for members is
      incorrect. The access should be changed to public or private to represent
      the correct intention of the field. This was probably caused by a change in
      use for this class, without completely changing all of the class to the new
      paradigm.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
   <Details>
      <![CDATA[
      <p>
      This detector looks for simple assignments of literal boolean values to variables in 
      conditional expressions.
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
   <Details>
      <![CDATA[
      <p>
      TrainNullReturnValues determines which methods may return null and saves
      them to a file.  The resulting file may be used in a subsequent
      pass to improve the precision of the null-dereference detector.
      Since this is just a training pass, no warnings are reported.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
   <Details>
      <![CDATA[
      <p>
      TrainUnconditionalParamDerefs determines which methods may
      unconditionally dereference parameters and saves them to a file.
      The resulting file may be used in a subsequent
      pass to improve the precision of the null-dereference detector.
      Since this is just a training pass, no warnings are reported.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
   <Details>
      <![CDATA[
      <p>
      TrainFieldStoreTypes analyzes the types stored into fields
      and stores them to a database.  The database may be used in a later
      pass to make type analysis more precise.
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
   <Details>
      <![CDATA[
      <p>
      TrainNonNullAnnotations collects @NonNull and @PossiblyNull annotations
      and stores them to database files.  This is a fast detector.
      </p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
   <Details>
      <![CDATA[
      <p>This detector is just for debugging method call resolution in FindBugs.
      Don't enable it.</p>
      ]]>
   </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[
<p> This detector just collects summary statistics information about the analysis process. </p>
]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[
    <p>
    This detector is a code example showing how to write a FindBugs
    detector using the ASM bytecode analysis framework.
    </p>
    ]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[
    <p> This detector looks at the arguments of calls to generic 
    collection methods that receive a <code>java.lang.Object</code>
    to see if the argument's type is related to the collection's 
    parameter. Arguments with unrelated class types are never going 
    to be in the collection. For example, if <code>foo</code> is a 
    <code>List&lt;String&gt;</code> and <code>bar</code> is a 
    <code>StringBuffer</code>, the call <code>foo.contains(bar)</code>
    will always return false. This is a fast detector. 
    </p>
    ]]>
    </Details>
  </Detector>

<Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
<Details>
<![CDATA[
<p>This detector warns about static fields of type java.util.Calendar or java.text.DateFormat (and subclasses) because
 Calendars are inherently unsafe for multithreaded use.
</p>
]]>
</Details>
</Detector>

  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[
      	<p>This is an internal detector used only for testing dataflow analyses.
      	It is not enabled by default.</p>
      ]]>
    </Details>
  </Detector>
  
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[
        <p>Check for violations of properties specified by JSR-305
        type qualifier annotations.</p>
      ]]>
    </Details>
  </Detector>
 <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[
        <p>Looks for an attempt to append to an object output stream</p>
      ]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
	  <Details>
		  <![CDATA[
		  <p>Checks @ExpectedWarning and @NoWarning annotations.
		  This detector is used only for testing FindBugs.</p>
		  ]]>
	  </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
	  <Details>
		  <![CDATA[
		  <p>Checks that if the result of putIfAbsent is ignored,
			the value passed as the second argument is not reused. </p>
		  ]]>
	  </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
	  <Details>
		  <![CDATA[
		  <p>Checks for methods invoked from constructors for superclasses.  </p>
		  ]]>
	  </Details>
  </Detector>

  <!--
  **********************************************************************
  BugPatterns
  **********************************************************************
   -->

  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
    <ShortDescription>Class too big for analysis</ShortDescription>
    <LongDescription>{0} is too big for analysis</LongDescription>
    <Details>
      <![CDATA[
	<p>This class is bigger than can be effectively handled, and was not fully analyzed for errors.
</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="NOISE_NULL_DEREFERENCE">
    <ShortDescription>Bogus warning about a null pointer dereference</ShortDescription>
    <LongDescription>Bogus warning about a null pointer dereference in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>Bogus warning.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>Bogus warning about a method call</ShortDescription>
    <LongDescription>Bogus warning about a method call {2} in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>Bogus warning.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>Bogus warning about a field reference</ShortDescription>
    <LongDescription>Bogus warning about a reference to {2} in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>Bogus warning.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>Bogus warning about an operation</ShortDescription>
    <LongDescription>Bogus warning about an operation {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>Bogus warning.</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>Useless/vacuous call to EasyMock method</ShortDescription>
    <LongDescription>Useless/vacuous call to {2} in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>This call doesn't pass any objects to the EasyMock method, so the call doesn't do anything.
</p><p>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>Creation of ScheduledThreadPoolExecutor with zero core threads</ShortDescription>
    <LongDescription>Creation of ScheduledThreadPoolExecutor with zero core threads in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)">Javadoc</a>)
A ScheduledThreadPoolExecutor with zero core threads will never execute anything; changes to the max pool size are ignored.
</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>Futile attempt to change max pool size of ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>Futile attempt to change max pool size of ScheduledThreadPoolExecutor in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>)
While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.
	</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>Call to unsupported method</ShortDescription>
    <LongDescription>Call to unsupported method {2} in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>All targets of this method invocation throw an UnsupportedOperationException.
</p>

]]>
    </Details>
  </BugPattern>



  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>Empty database password</ShortDescription>
    <LongDescription>Empty database password in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>This code creates a database connect using a blank or empty password. This indicates that the database is not protected by a password. 
</p><p>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>Hardcoded constant database password</ShortDescription>
    <LongDescription>Hardcoded constant database password in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>This code creates a database connect using a hardcoded, constant password. Anyone with access to either the source code or the compiled code can 
	easily learn the password.
</p><p>代码中创建DB的密码时采用了写死的密码。</p>

]]>
    </Details>
  </BugPattern>


  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>HTTP cookie formed from untrusted input</ShortDescription>
    <LongDescription>HTTP cookie formed from untrusted input in {1}</LongDescription>
    <Details>
      <![CDATA[
	<p>This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added to an HTTP response, it will allow a HTTP response splitting
vulnerability. See <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of HTTP response splitting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more 
vulnerabilities that FindBugs doesn't report. If you are concerned about HTTP response splitting, you should seriously 
consider using a commercial static analysis or pen-testing tool.
</p><p>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。</p>

]]>
    </Details>
  </BugPattern>

    <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
        <ShortDescription>HTTP Response splitting vulnerability</ShortDescription>
      <LongDescription>HTTP parameter directly written to HTTP header output in {1}</LongDescription>
        <Details>
            <![CDATA[
	<p>This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP response splitting
vulnerability. See <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of HTTP response splitting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more 
vulnerabilities that FindBugs doesn't report. If you are concerned about HTTP response splitting, you should seriously 
consider using a commercial static analysis or pen-testing tool.
</p><p>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。</p>

]]>
        </Details>
    </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>HTTP parameter written to Servlet output {1}</LongDescription>
<Details>
<![CDATA[
	<p>This code directly writes an HTTP parameter to Servlet output, which allows for a reflected cross site scripting
vulnerability. See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of cross site scripting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more cross site scripting
vulnerabilities that FindBugs doesn't report. If you are concerned about cross site scripting, you should seriously 
consider using a commercial static analysis or pen-testing tool.
</p><p>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>Servlet reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>HTTP parameter written to Servlet error page in {1}</LongDescription>
<Details>
<![CDATA[
	<p>This code directly writes an HTTP parameter to a Server error page (using HttpServletResponse.sendError). Echoing this untrusted input allows
for a reflected cross site scripting
vulnerability. See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of cross site scripting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more cross site scripting
vulnerabilities that FindBugs doesn't report. If you are concerned about cross site scripting, you should seriously 
consider using a commercial static analysis or pen-testing tool.
</p><p>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>JSP reflected cross site scripting vulnerability</ShortDescription>
    <LongDescription>HTTP parameter directly written to JSP output, giving reflected XSS vulnerability in {1.class}</LongDescription>
<Details>
<![CDATA[
	<p>This code directly writes an HTTP parameter to JSP output, which allows for a cross site scripting
vulnerability. See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of cross site scripting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more cross site scripting
vulnerabilities that FindBugs doesn't report. If you are concerned about cross site scripting, you should seriously 
consider using a commercial static analysis or pen-testing tool.
</p><p>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>Certain swing methods needs to be invoked in Swing thread</ShortDescription>
    <LongDescription>Call to swing method in {1} needs to be performed in Swing event thread</LongDescription>
    <Details>
<![CDATA[
<p>(<a href="http://java.sun.com/developer/JDCTechTips/2003/tt1208.html#1">From JDC Tech Tip</a>): The Swing methods
show(), setVisible(), and pack() will create the associated peer for the frame.
With the creation of the peer, the system creates the event dispatch thread.
This makes things problematic because the event dispatch thread could be notifying
listeners while pack and validate are still processing. This situation could result in
two threads going through the Swing component-based GUI -- it's a serious flaw that
could result in deadlocks or other related threading issues. A pack call causes
components to be realized. As they are being realized (that is, not necessarily
visible), they could trigger listener notification on the event dispatch thread.</p>

]]>
    </Details>
  </BugPattern>


  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>An apparent infinite loop</ShortDescription>
    <LongDescription>There is an apparent infinite loop in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This loop doesn't seem to have a way to terminate (other than by perhaps
throwing an exception).</p><p>方法的自调用引起的死循环</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>An apparent infinite recursive loop</ShortDescription>
    <LongDescription>There is an apparent infinite recursive loop in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This method unconditionally invokes itself. This would seem to indicate
an infinite recursive loop that will result in a stack overflow.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>A collection is added to itself</ShortDescription>
    <LongDescription>A collection is added to itself in {1}</LongDescription>
    <Details>
<![CDATA[
<p>A collection is added to itself. As a result, computing the hashCode of this
set will throw a StackOverflowException.
</p><p>集合本身作为add方法的参数，这样会引起内容溢出。</p>
]]>
    </Details>
  </BugPattern>




  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>A volatile reference to an array doesn't treat the array elements as volatile</ShortDescription>
    <LongDescription>{1} is a volatile reference to an array; the array elements are non-volatile</LongDescription>
    <Details>
<![CDATA[
<p>This declares a volatile reference to an array, which might not be what
you want. With a volatile reference to an array, reads and writes of
the reference to the array are treated as volatile, but the array elements
are non-volatile. To get volatile array elements, you will need to use
one of the atomic array classes in java.util.concurrent (provided
in Java 5.0).</p><p>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>Usage of GetResource may be unsafe if class is extended</ShortDescription>
    <LongDescription>Usage of GetResource in {1} may be unsafe if class is extended</LongDescription>
    <Details>
<![CDATA[
<p>Calling <code>this.getClass().getResource(...)</code> could give
results other than expected if this class is extended by a class in
another package.</p><p>当一个类被子类继承后不要使用this.getClass().getResource(...)来获取资源</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
  	<ShortDescription>Method with Boolean return type returns explicit null</ShortDescription>
  	<LongDescription>{1} has Boolean return type and returns explicit null</LongDescription>
  	<Details>
  	 <![CDATA[
  	 <p>
	A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen.
	This method can be invoked as though it returned a value of type boolean, and
	the compiler will insert automatic unboxing of the Boolean value. If a null value is returned,
	this will result in a NullPointerException.
  	 </p><p>返回值为boolean类型的方法直接返回null，这样会导致空指针异常</p>
  	 ]]>
  	 </Details>
  	 </BugPattern>


   <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
     <ShortDescription>Synchronize and null check on the same field.</ShortDescription>
     <LongDescription>In {1} the field {2.givenClass} is synchronized on and then checked if null.</LongDescription>
     <Details>
<![CDATA[
<p>Since the field is synchronized on, it seems not likely to be null.
If it is null and then synchronized on a NullPointerException will be
thrown and the check would be pointless. Better to synchronize on 
another field.</p><p>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。</p>

]]>
     </Details>
   </BugPattern>


  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>Repeated conditional tests</ShortDescription>
    <LongDescription>Repeated conditional test in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code contains a conditional test is performed twice, one right after the other
(e.g., <code>x == 0 || x == 0</code>). Perhaps the second occurrence is intended to be something else
(e.g., <code>x == 0 || y == 0</code>). 
</p><p>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="TESTING">
    <ShortDescription>Testing</ShortDescription>
    <LongDescription>Test warning generated in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This bug pattern is only generated by new, incompletely implemented
bug detectors.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="UNKNOWN">
    <ShortDescription>Unknown bug pattern</ShortDescription>
    <LongDescription>Unknown bug pattern BUG_PATTERN in {1}</LongDescription>
    <Details>
<![CDATA[
<p>A warning was recorded, but findbugs can't find the description of this bug pattern
and so can't describe it. This should occur only in cases of a bug in FindBugs or its configuration,
or perhaps if an analysis was generated using a plugin, but that plugin is not currently loaded.
.</p><p>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="TESTING">
    <ShortDescription>Prototype bug report</ShortDescription>
    <LongDescription>Instance of prototype/incomplete bug pattern in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This bug pattern is used by prototype/incomplete/experimental bug detectors.
</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="TESTING2">
    <ShortDescription>2nd kind of prototype bug report</ShortDescription>
    <LongDescription>Instance of 2nd kind of prototype/incomplete bug pattern in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This bug pattern is  the second pattern reported by used by prototype/incomplete/experimental bug detectors.
</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>Creates an empty zip file entry</ShortDescription>
    <LongDescription>Empty zip file entry created in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>. This results
in an empty ZipFile entry. The contents of the entry
should be written to the ZipFile between the calls to
<code>putNextEntry()</code> and
<code>closeEntry()</code>.</p><p>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>Creates an empty jar file entry</ShortDescription>
    <LongDescription>Empty jar file entry created in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code calls <code>putNextEntry()</code>, immediately
followed by a call to <code>closeEntry()</code>. This results
in an empty JarFile entry. The contents of the entry
should be written to the JarFile between the calls to
<code>putNextEntry()</code> and
<code>closeEntry()</code>.</p><p>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>Dubious catching of IllegalMonitorStateException</ShortDescription>
    <LongDescription>Dubious catching of IllegalMonitorStateException in {1}</LongDescription>
    <Details>
<![CDATA[
<p>IllegalMonitorStateException is generally only
   thrown in case of a design flaw in your code (calling wait or
   notify on an object you do not hold a lock on).</p><p>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>Method performs math using floating point precision</ShortDescription>
    <LongDescription>{1} performs math using floating point precision</LongDescription>
    <Details>
<![CDATA[
<p>
   The method performs math operations using floating point precision.
   Floating point precision is very imprecise. For example,
   16777216.0f + 1.0f = 16777216.0f. Consider using double math instead.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CN_IDIOM">
    <ShortDescription>Class implements Cloneable but does not define or use clone method</ShortDescription>
    <LongDescription>Class {0} implements Cloneable but does not define or use clone method</LongDescription>
    <Details>
<![CDATA[
<p>
   Class implements Cloneable but does not define or
   use the clone method.</p><p>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone</p><p>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>Class defines clone() but doesn't implement Cloneable</ShortDescription>
    <LongDescription>{0} defines clone() but doesn't implement Cloneable</LongDescription>
    <Details>
<![CDATA[
<p> This class defines a clone() method but the class doesn't implement Cloneable.
There are some situations in which this is OK (e.g., you want to control how subclasses 
can clone themselves), but just make sure that this is what you intended.
</p>
<p>
这个类声明了一个clone()方法，但却没有实现Cloneable接口。最好不要这样，除非你有意为之。
</p><p>类中定义了clone方法但是它没有实现Cloneable接口</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>clone method does not call super.clone()</ShortDescription>
    <LongDescription>{1} does not call super.clone()</LongDescription>
    <Details>
<![CDATA[
<p> This non-final class defines a clone() method that does not call super.clone().
If this class ("<i>A</i>") is extended by a subclass ("<i>B</i>"),
and the subclass <i>B</i> calls super.clone(), then it is likely that
<i>B</i>'s clone() method will return an object of type <i>A</i>,
which violates the standard contract for clone().</p>

<p> If all clone() methods call super.clone(), then they are guaranteed
to use Object.clone(), which always returns an object of the correct type.</p><p>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} uses {2} for a variable name, which is a keyword in later versions of Java</LongDescription>
    <Details>
<![CDATA[
<p>The identifier is a word that is reserved as a keyword in later versions of Java, and your code will need to be changed
in order to compile it in later versions of Java.</p><p>验证是否是java预留关键字</p>

]]>
    </Details>
  </BugPattern>
   <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>Use of identifier that is a keyword in later versions of Java</ShortDescription>
    <LongDescription>{1} conflicts with a keyword in a more recent version of Java</LongDescription>
    <Details>
<![CDATA[
<p>This identifier is used as a keyword in later versions of Java. This code, and 
any code that references this API, 
will need to be changed in order to compile it in later versions of Java.</p><p>验证是否时java中的关键字</p>

]]>
    </Details>
  </BugPattern>
  

  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>Method might drop exception</ShortDescription>
    <LongDescription>{1} might drop {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method might drop an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.</p><p>方法可能抛出异常</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>Method might ignore exception</ShortDescription>
    <LongDescription>{1} might ignore {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method might ignore an exception.&nbsp; In general, exceptions
  should be handled or reported in some way, or they should be thrown
  out of the method.</p><p>方法可能忽略异常</p>
]]>
    </Details>
  </BugPattern>

<BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>{1} invokes {2}, which should be invoked from within a doPrivileged block</LongDescription>
    <Details>
<![CDATA[
  <p> This code invokes a method that requires a security permission check.
  If this code will be granted security permissions, but might be invoked by code that does not
  have security permissions, then the invocation needs to occur inside a doPrivileged block.</p>
<p>
此代码调用一个方法，需要一个安全权限检查。如果此代码将被授予安全权限，但可能是由代码不具有安全权限调用，则需要调用发生在一个doPrivileged的块。
</p>
]]>
    </Details>
  </BugPattern>
<BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>Method invoked that should be only be invoked inside a doPrivileged block</ShortDescription>
    <LongDescription>{1} invokes {2}, which should be invoked from within a doPrivileged block</LongDescription>
    <Details>
<![CDATA[
  <p> This code invokes a method that requires a security permission check.
  If this code will be granted security permissions, but might be invoked by code that does not
  have security permissions, then the invocation needs to occur inside a doPrivileged block.</p>
]]>
    </Details>
  </BugPattern>

<BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} creates a {2} classloader, which should be performed within a doPrivileged block</LongDescription>
    <Details>
<![CDATA[
  <p> This code creates a classloader,  which requires a security manager.
  If this code will be granted security permissions, but might be invoked by code that does not
  have security permissions, then the classloader creation needs to occur inside a doPrivileged block.</p><p>类加载器只能建立在特殊的方法体内</p>
]]>
    </Details>
  </BugPattern>
<BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEDGED"> <!-- misspelled for backward compatibility -->
    <ShortDescription>Classloaders should only be created inside doPrivileged block</ShortDescription>
    <LongDescription>{1} creates a {2} classloader, which should be performed within a doPrivileged block</LongDescription>
    <Details>
<![CDATA[
  <p> This code creates a classloader,  which requires a security manager.
  If this code will be granted security permissions, but might be invoked by code that does not
  have security permissions, then the classloader creation needs to occur inside a doPrivileged block.</p><p>类加载器只能建立在特殊的方法体内</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
    <ShortDescription>Fields of immutable classes should be final</ShortDescription>
    <LongDescription>{1.givenClass} should be final since {0} is marked as Immutable.  </LongDescription>
    <Details>
<![CDATA[
  <p> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require
that all fields are final.
   .</p><p>The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
    <ShortDescription>Thread passed where Runnable expected</ShortDescription>
    <LongDescription>Thread passed where Runnable expected in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> A Thread object is passed as a parameter to a method where 
a Runnable is expected. This is rather unusual, and may indicate a logic error
or cause unexpected behavior.
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>Maps and sets of URLs can be performance hogs</ShortDescription>
    <LongDescription>{1} is or uses a map or set of URLs, which can be a performance hog</LongDescription>
    <Details>
<![CDATA[
  <p> This method or field is or uses a Map or Set of URLs. Since both the equals and hashCode
method of URL perform domain name resolution, this can result in a big performance hit.
See <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> for more information.
Consider using <code>java.net.URI</code> instead.
   </p><p>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
    <ShortDescription>The equals and hashCode methods of URL are blocking</ShortDescription>
    <LongDescription>{1} invokes {2}, which blocks to do domain name resolution</LongDescription>
    <Details>
<![CDATA[
  <p> The equals and hashCode
method of URL perform domain name resolution, this can result in a big performance hit.
See <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> for more information.
Consider using <code>java.net.URI</code> instead.
   </p><p>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>Can't use reflection to check for presence of annotation without runtime retention</ShortDescription>
    <LongDescription>{1} uses reflection to check for the presence the annotation {3} which doesn't have runtime retention</LongDescription>
    <Details>
<![CDATA[
  <p> Unless an annotation has itself been annotated with  @Retention(RetentionPolicy.RUNTIME), the annotation can't be observed using reflection
(e.g., by using the isAnnotationPresent method).
   .</p><p>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can't be observed using reflection (e.g., by using the isAnnotationPresent method). .</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="DM_EXIT">
    <ShortDescription>Method invokes System.exit(...)</ShortDescription>
    <LongDescription>{1} invokes System.exit(...), which shuts down the entire virtual machine</LongDescription>
    <Details>
<![CDATA[
  <p> Invoking System.exit shuts down the entire Java virtual machine. This
   should only been done when it is appropriate. Such calls make it
   hard or impossible for your code to be invoked by other code.
   Consider throwing a RuntimeException instead.</p><p>在方法中调用System.exit(...)语句，考虑用RuntimeException来代替</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>Method invokes dangerous method runFinalizersOnExit</ShortDescription>
    <LongDescription>{1} invokes dangerous method runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[
  <p> <em>Never call System.runFinalizersOnExit
or Runtime.runFinalizersOnExit for any reason: they are among the most
dangerous methods in the Java libraries.</em> -- Joshua Bloch</p><p>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>Method invokes inefficient new String(String) constructor</ShortDescription>
    <LongDescription>{1} invokes inefficient new String(String) constructor</LongDescription>
    <Details>
<![CDATA[
  <p> Using the <code>java.lang.String(String)</code> constructor wastes memory
  because the object so constructed will be functionally indistinguishable
  from the <code>String</code> passed as a parameter.&nbsp; Just use the
  argument <code>String</code> directly.</p><p>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>Method invokes inefficient new String() constructor</ShortDescription>
    <LongDescription>{1} invokes inefficient new String() constructor</LongDescription>
    <Details>
<![CDATA[
  <p> Creating a new <code>java.lang.String</code> object using the
  no-argument constructor wastes memory because the object so created will
  be functionally indistinguishable from the empty string constant
  <code>""</code>.&nbsp; Java guarantees that identical string constants
  will be represented by the same <code>String</code> object.&nbsp; Therefore,
  you should just use the empty string constant directly.</p><p>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
    <ShortDescription>Method invokes toString() method on a String</ShortDescription>
    <LongDescription>Method {1} invokes toString() method on a String</LongDescription>
    <Details>
<![CDATA[
  <p> Calling <code>String.toString()</code> is just a redundant operation.
  Just use the String.</p><p>调用String.toString()是多余的操作，只要使用String就可以了。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>Explicit garbage collection; extremely dubious except in benchmarking code</ShortDescription>
    <LongDescription>{1} forces garbage collection; extremely dubious except in benchmarking code</LongDescription>
    <Details>
<![CDATA[
  <p> Code explicitly invokes garbage collection.
  Except for specific use in benchmarking, this is very dubious.</p>
  <p>In the past, situations where people have explicitly invoked
  the garbage collector in routines such as close or finalize methods
  has led to huge performance black holes. Garbage collection
   can be expensive. Any situation that forces hundreds or thousands
   of garbage collections will bring the machine to a crawl.</p>
   
   <p>
   <code>System.gc()</code>只是建议，不是命令，不能保证JVM会立刻执行垃圾回收。建议去掉<code>System.gc()</code>。
   </p>
   <p>
   System.gc()被显示调用时，很大可能会触发Full GC。
   GC有两种类型：Scavenge GC和Full GC，Scavenge GC一般是针对年轻代区（Eden区）进行GC，
不会影响老年代和永生代（PerGen），由于大部分对象都是从Eden区开始的，所以Scavenge GC会频繁进行，
GC算法速度也更快，效率更高。但是Full GC不同，Full GC是对整个堆进行整理，包括Young、Tenured和Perm，
所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。
   </p><p>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</ShortDescription>
    <LongDescription>{1} invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead</LongDescription>
    <Details>
<![CDATA[
  <p> Creating new instances of <code>java.lang.Boolean</code> wastes
  memory, since <code>Boolean</code> objects are immutable and there are
  only two useful values of this type.&nbsp; Use the <code>Boolean.valueOf()</code>
  method (or Java 1.5 autoboxing) to create <code>Boolean</code> objects instead.</p>
<p>
直接实例化一个<code>java.lang.Boolean</code>对象会降低性能。静态工厂<code>Boolean.valueOf(boolean)是一个更好地选择。
</p><p>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DM_NUMBER_CTOR">
    <ShortDescription>Method invokes inefficient Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>Method {1} invokes inefficient {2} constructor; use {3} instead</LongDescription>
    <Details>
      <![CDATA[
      <p>
      Using <code>new Integer(int)</code> is guaranteed to always result in a new object whereas
      <code>Integer.valueOf(int)</code> allows caching of values to be done by the compiler, class library, or JVM.
      Using of cached values avoids object allocation and the code will be faster.
      </p>
      <p>
      Values between -128 and 127 are guaranteed to have corresponding cached instances
      and using <code>valueOf</code> is approximately 3.5 times faster than using constructor.
      For values outside the constant range the performance of both styles is the same.
      </p>
      <p>
      Unless the class must be compatible with JVMs predating Java 1.5,
      use either autoboxing or the <code>valueOf()</code> method when creating instances of
      <code>Long</code>, <code>Integer</code>, <code>Short</code>, <code>Character</code>, and <code>Byte</code>.
      </p>
<p>
使用<code>new Integer(int)</code>将导致效率低下，因为这样做可能是要创建一个对象。而使用<code>Integer.valueOf(int)</code>可以让编译器、类库或者JVM缓存着一些值，提高效率。
</p>
<p>
FindBugs推荐使用Integer.ValueOf(int)代替new Integer(int)，因为这样可以提高性能。如果当你的int值介于-128～127时，Integer.ValueOf(int)的效率比Integer(int)快大约3.5倍。
</p><p>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
    <ShortDescription>Method invokes inefficient floating-point Number constructor; use static valueOf instead</ShortDescription>
    <LongDescription>Method {1} invokes inefficient {3} constructor; use {4} instead</LongDescription>
    <Details>
      <![CDATA[
      <p>
      Using <code>new Double(double)</code> is guaranteed to always result in a new object whereas
      <code>Double.valueOf(double)</code> allows caching of values to be done by the compiler, class library, or JVM.
      Using of cached values avoids object allocation and the code will be faster.
      </p>
      <p>
      Unless the class must be compatible with JVMs predating Java 1.5,
      use either autoboxing or the <code>valueOf()</code> method when creating instances of <code>Double</code> and <code>Float</code>.
      </p>
	  <p>
	  使用<code>new Double(double)</code>，影响程序效率。建议使用<code>Double.valueOf(double)</code>。
	  </p><p>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。</p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>Consider using Locale parameterized version of invoked method</ShortDescription>
    <LongDescription>Use of non-localized String.toUpperCase() or String.toLowerCase</LongDescription>
    <Details>
<![CDATA[
  <p> A String is being converted to upper or lowercase, using the platform's default encoding. This may
      result in improper conversions when used with international characters. Use the </p>
      <ul>
	<li>String.toUpperCase( Locale l )</li>
	<li>String.toLowerCase( Locale l )</li>
	</ul>
      <p>versions instead.</p><p>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换String.toUpperCase( Locale l )String.toLowerCase( Locale l )</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>Primitive value is unboxed and coerced for ternary operator</ShortDescription>
    <LongDescription>Primitive value is unboxed and coerced for ternary operator in {1}</LongDescription>
    <Details>
<![CDATA[
  <p>A wrapped primitive value is unboxed and converted to another primitive type as part of the
evaluation of a conditional ternary operator (the <code> b ? e1 : e2</code> operator). The
semantics of Java mandate that if <code>e1</code> and <code>e2</code> are wrapped
numeric values, the values are unboxed and converted/coerced to their common type (e.g,
if <code>e1</code> is of type <code>Integer</code> 
and <code>e2</code> is of type <code>Float</code>, then <code>e1</code> is unboxed,
converted to a floating point value, and boxed. See JLS Section 15.25.
</p><p>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
    <ShortDescription>Primitive value is boxed and then immediately unboxed</ShortDescription>
    <LongDescription>Primitive value is boxed and then immediately unboxed in {1}</LongDescription>
    <Details>
<![CDATA[
  <p>A primitive is boxed, and then immediately unboxed. This probably is due to a manual
	boxing in a place where an unboxed value is required, thus forcing the compiler
to immediately undo the work of the boxing.
</p><p>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作</p><p>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：new Double(d).intValue()应该直接进行强制转换例如：(int) d</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>Primitive value is boxed then unboxed to perform primitive coercion</ShortDescription>
    <LongDescription>Primitive value is boxed then unboxed to perform primitive coercion in {1}</LongDescription>
    <Details>
<![CDATA[
  <p>A primitive boxed value constructed and then immediately converted into a different primitive type
(e.g., <code>new Double(d).intValue()</code>). Just perform direct primitive coercion (e.g., <code>(int) d</code>).</p><p>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：new Double(d).intValue()应该直接进行强制转换例如：(int) d</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>Method allocates a boxed primitive just to call toString</ShortDescription>
    <LongDescription>Primitive boxed just to call toString in {1}</LongDescription>
    <Details>
<![CDATA[
  <p>A boxed primitive is allocated just to call toString(). It is more effective to just use the static
  form of toString which takes the primitive value. So,</p>
  <table>
     <tr><th>Replace...</th><th>With this...</th></tr>
     <tr><td>new Integer(1).toString()</td><td>Integer.toString(1)</td></tr>
     <tr><td>new Long(1).toString()</td><td>Long.toString(1)</td></tr>
     <tr><td>new Float(1.0).toString()</td><td>Float.toString(1.0)</td></tr>
     <tr><td>new Double(1.0).toString()</td><td>Double.toString(1.0)</td></tr>
     <tr><td>new Byte(1).toString()</td><td>Byte.toString(1)</td></tr>
     <tr><td>new Short(1).toString()</td><td>Short.toString(1)</td></tr>
     <tr><td>new Boolean(true).toString()</td><td>Boolean.toString(true)</td></tr>
  </table><p>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：new Integer(1).toString()    替换为   Integer.toString(1)new Long(1).toString()    替换为   Long.toString(1)new Float(1.0).toString()    替换为   Float.toString(1.0)new Double(1.0).toString()    替换为   Double.toString(1.0)new Byte(1).toString()    替换为   Byte.toString(1)new Short(1).toString()    替换为   Short.toString(1)new Boolean(true).toString()    替换为   Boolean.toString(true)</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>Method allocates an object, only to get the class object</ShortDescription>
    <LongDescription>Method {1} allocates an object, only to get the class object</LongDescription>
    <Details>
<![CDATA[
  <p>This method allocates an object just to call getClass() on it, in order to
  retrieve the Class object for it. It is simpler to just access the .class property of the class.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
   <ShortDescription>Monitor wait() called on Condition</ShortDescription>
   <LongDescription>Monitor wait() called on a Condition in {1}</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method calls <code>wait()</code> on a
      <code>java.util.concurrent.locks.Condition</code> object.&nbsp;
      Waiting for a <code>Condition</code> should be done using one of the <code>await()</code>
      methods defined by the <code>Condition</code> interface.
      </p><p>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="RV_01_TO_INT">
    <ShortDescription>Random value from 0 to 1 is coerced to the integer 0</ShortDescription>
    <LongDescription>Method {1} uses generates a random value from 0 to 1 and then coerces that value to the integer 0</LongDescription>
    <Details>
<![CDATA[
  <p>A random value from 0 to 1 is being coerced to the integer value 0. You probably
want to multiple the random value by something else before coercing it to an integer, or use the <code>Random.nextInt(n)</code> method.
</p><p>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>Use the nextInt method of Random rather than nextDouble to generate a random integer</ShortDescription>
    <LongDescription>Method {1} uses the nextDouble method of Random to generate a random integer; using nextInt is more efficient</LongDescription>
    <Details>
<![CDATA[
  <p>If <code>r</code> is a <code>java.util.Random</code>, you can generate a random number from <code>0</code> to <code>n-1</code>
using <code>r.nextInt(n)</code>, rather than using <code>(int)(r.nextDouble() * n)</code>.
</p><p>如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
    <ShortDescription>Nonconstant string passed to execute method on an SQL statement</ShortDescription>
    <LongDescription>Method {1} passes a nonconstant String to an execute method on an SQL statement</LongDescription>
    <Details>
<![CDATA[
  <p>The method invokes the execute method on an SQL statement with a String that seems
to be dynamically generated. Consider using
a prepared statement instead. It is more efficient and less vulnerable to
SQL injection attacks.
</p><p>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>A prepared statement is generated from a nonconstant String</ShortDescription>
    <LongDescription>A prepared statement is generated from a nonconstant String at {1} </LongDescription>
    <Details>
<![CDATA[
  <p>The code creates an SQL prepared statement from a nonconstant String.
If unchecked, tainted data from a user is used in building this String, SQL injection could
be used to make the prepared statement do something unexpected and undesirable.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>A thread was created using the default empty run method</ShortDescription>
    <LongDescription>Method {1} creates a thread using the default empty run method</LongDescription>
    <Details>
<![CDATA[
  <p>This method creates a thread without specifying a run method either by deriving from the Thread class, or
  by passing a Runnable object. This thread, then, does nothing but waste time.
</p><p>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DC_DOUBLECHECK">
    <ShortDescription>Possible double check of field</ShortDescription>
    <LongDescription>Possible doublecheck on {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method may contain an instance of double-checked locking.&nbsp;
  This idiom is not correct according to the semantics of the Java memory
  model.&nbsp; For more information, see the web page
  <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
  >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
    <ShortDescription>Finalizer nulls fields</ShortDescription>
    <LongDescription>{3} is set to null inside finalize method</LongDescription>
	<Details>
<![CDATA[
  <p> This finalizer nulls out fields.  This is usually an error, as it does not aid garbage collection,
  and the object is going to be garbage collected anyway.  
<p>
<code>finalize()</code>方法是用来释放非JAVA资源的，在<code>finalize()</code>将字段置空是多此一举，而且这并不会对垃圾回收有帮助。
</p>
]]>
	</Details>
   </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>Finalizer only nulls fields</ShortDescription>
    <LongDescription>{1} only nulls fields</LongDescription>
	<Details>
<![CDATA[
  <p> This finalizer does nothing except null out fields. This is completely pointless, and requires that
the object be garbage collected, finalized, and then garbage collected again. You should just remove the finalize
method.
]]>
	</Details>
   </BugPattern>

  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>Finalizer should be protected, not public</ShortDescription>
    <LongDescription>{1} is public; should be protected</LongDescription>
    <Details>
<![CDATA[
  <p> A class's <code>finalize()</code> method should have protected access,
   not public.</p>
<p>
<code>finalize()</code>方法应该被声明为<code>protected</code>的。
</p><p>一个类中的finalize（）方法必须声明为protected，而不能为public类型</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_EMPTY">
    <ShortDescription>Empty finalizer should be deleted</ShortDescription>
    <LongDescription>{1} is empty and should be deleted</LongDescription>
    <Details>
<![CDATA[
  <p> Empty <code>finalize()</code> methods are useless, so they should
  be deleted.</p>
  <p>
  空的<code>finalize()</code>是毫无作用的，应该删除掉。
  </p><p>为空的finalizer方法应该删除。一下关于finalizer的内容省略</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>Finalizer nullifies superclass finalizer</ShortDescription>
    <LongDescription>{1} is nullifying {2}.finalize(); is this intended?</LongDescription>
    <Details>
<![CDATA[
  <p> This empty <code>finalize()</code> method explicitly negates the
  effect of any finalizer defined by its superclass.&nbsp; Any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Unless this is intended, delete this method.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_USELESS">
    <ShortDescription>Finalizer does nothing but call superclass finalizer</ShortDescription>
    <LongDescription>{1} does nothing except call super.finalize(); delete it</LongDescription>
    <Details>
<![CDATA[
  <p> The only thing this <code>finalize()</code> method does is call
  the superclass's <code>finalize()</code> method, making it
  redundant.&nbsp; Delete it.</p>
<p>
<code>finalize()</code>是一个用于释放非java资源的方法。这一个<code>finalize()</code>方法仅仅调用了父类的<code>finalize()</code>方法，因此是多余的。应该将它删除。
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>Finalizer does not call superclass finalizer</ShortDescription>
    <LongDescription>{1} missing call to super.finalize(), so {2}.finalize() doesn't get called</LongDescription>
    <Details>
<![CDATA[
  <p> This <code>finalize()</code> method does not make a call to its
  superclass's <code>finalize()</code> method.&nbsp; So, any finalizer
  actions defined for the superclass will not be performed.&nbsp;
  Add a call to <code>super.finalize()</code>.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="FI_EXPLICIT_INVOCATION">
    <ShortDescription>Explicit invocation of finalizer</ShortDescription>
    <LongDescription>{1} explicitly invokes {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains an explicit invocation of the <code>finalize()</code>
  method on an object.&nbsp; Because finalizer methods are supposed to be
  executed once, and only by the VM, this is a bad idea.</p>
<p>If a connected set of objects beings finalizable, then the VM will invoke the
finalize method on all the finalizable object, possibly at the same time in different threads.
Thus, it is a particularly bad idea, in the finalize method for a class X, invoke finalize
on objects referenced by X, because they may already be getting finalized in a separate thread.
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>Equals checks for noncompatible operand</ShortDescription>
    <LongDescription>{1} checks for operand being a {2.givenClass} </LongDescription>
    <Details>
<![CDATA[
  <p> This equals method is checking to see if the argument is some incompatible type
(i.e., a class that is neither a supertype nor subtype of the class that defines
the equals method). For example, the Foo class might have an equals method
that looks like:

<p><code><pre>
public boolean equals(Object o) {
  if (o instanceof Foo)
    return name.equals(((Foo)o).name);
  else if (o instanceof String)
    return name.equals(o);
  else return false;
</pre></code></p>

<p>This is considered bad practice, as it makes it very hard to implement an equals method that
is symmetric and transitive. Without those properties, very unexpected behavoirs are possible.
</p><p>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。public boolean equals(Object o) {if (o instanceof Foo)return name.equals(((Foo)o).name);else if (o instanceof String)return name.equals(o);else return false;</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
    <ShortDescription>Covariant equals() method defined for enum</ShortDescription>
    <LongDescription>enum {0} defines equals({0.givenClass})</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines an enumeration, and equality on enumerations are defined
using object identity. Defining a covariant equals method for an enumeration
value is exceptionally bad practice, since it would likely result
in having two different enumeration values that compare as equals using
the covariant enum method, and as not equal when compared normally.
Don't do it.
</p><p>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don't do it.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>Covariant equals() method defined, Object.equals(Object) inherited</ShortDescription>
    <LongDescription>{0} defines equals({0.givenClass}) method and uses Object.equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of the <code>equals()</code>
  method, but inherits the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp;
  The class should probably define a <code>boolean equals(Object)</code> method.
  </p>
  <p>
  这个类<em>重载</em>而不是<em>覆盖</em>了<code>equals()</code>方法。除非传入的参数和这个方法的参数的类型一致，否则不会调用这个方法。
  </p><p>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>equals() method defined that doesn't override Object.equals(Object)</ShortDescription>
    <LongDescription>{0} defines {1.givenClass} method and uses Object.equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines an <code>equals()</code>
  method, that doesn't override the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp;
  The class should probably define a <code>boolean equals(Object)</code> method.
  </p><p>类中定义的equals方法时不要覆写Object中的equals（Object）方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>equals() method defined that doesn't override equals(Object)</ShortDescription>
    <LongDescription>{0} defines {1.givenClass} method that doesn't override equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines an <code>equals()</code>
  method, that doesn't override the normal <code>equals(Object)</code> method
  defined in the base <code>java.lang.Object</code> class.&nbsp; Instead, it 
  inherits an <code>equals(Object)</code> method from a superclass.
  The class should probably define a <code>boolean equals(Object)</code> method.
  </p><p>类中定义的equals方法时不要覆写equals（Object）方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
    <ShortDescription>Class doesn't override equals in superclass</ShortDescription>
    <LongDescription>{0} doesn't override {1.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p> This class extends a class that defines an equals method and adds fields, but doesn't
define an equals method itself. Thus, equality on instances of this class will
ignore the identity of the subclass and the added fields. Be sure this is what is intended,
and that you don't need to override the equals method. Even if you don't need to override
the equals method, consider overriding it anyway to document the fact
that the equals method for the subclass just return the result of
invoking super.equals(o).
  </p><p>子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
    <ShortDescription>Covariant equals() method defined</ShortDescription>
    <LongDescription>{0} defines equals({0.givenClass}) method but not equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.</p><p>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。</p><p></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>equals method overrides equals in superclass and may not be symmetric</ShortDescription>
    <LongDescription>{1.class} overrides equals in {2.class.givenClass} and may not be symmetric</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines an equals method that overrides an equals method in a superclass. Both equals methods
methods use <code>instanceof</code> in the determination of whether two objects are equal. This is fraught with peril,
since it is important that the equals method is symmetrical (in other words, <code>a.equals(b) == b.equals(a)</code>).
If B is a subtype of A, and A's equals method checks that the argument is an instanceof A, and B's equals method
checks that the argument is an instanceof B, it is quite likely that the equivalence relation defined by these
methods is not symmetric.
</p><p></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>equals method fails for subtypes</ShortDescription>
    <LongDescription>{1} fails for subtypes</LongDescription>
    <Details>
<![CDATA[
  <p> This class has an equals method that will be broken if it is inherited by subclasses.
It compares a class literal with the class of the argument (e.g., in class <code>Foo</code>
it might check if <code>Foo.class == o.getClass()</code>).
It is better to check if <code>this.getClass() == o.getClass()</code>.
</p><p>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>Unusual equals method </ShortDescription>
    <LongDescription>{1} is unusual</LongDescription>
    <Details>
<![CDATA[
  <p> This class doesn't do any of the patterns we recognize for checking that the type of the argument 
is compatible with the type of the <code>this</code> object. There might not be anything wrong with
this code, but it is worth reviewing.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals method compares class names rather than class objects</ShortDescription>
    <LongDescription>{1} compares class names rather than class objects</LongDescription>
    <Details>
<![CDATA[
  <p> This method checks to see if two objects are the same class by checking to see if the names
of their classes are equal. You can have different classes with the same name if they are loaded by
different class loaders. Just check to see if the class objects are the same.
</p><p>使用equals方法去比较一个类的实例和类的类型</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EQ_ALWAYS_TRUE">
    <ShortDescription>equals method always returns true</ShortDescription>
    <LongDescription>{1} always returns true</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines an equals method that always returns true. This is imaginative, but not very smart.
Plus, it means that the equals method is not symmetric.
</p><p>equals方法返回值总是true</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals method always returns false</ShortDescription>
    <LongDescription>{1} always returns false</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines an equals method that always returns false. This means that an object is not equal to itself, and it is impossible to create useful Maps or Sets of this class. More fundamentally, it means
that equals is not reflexive, one of the requirements of the equals method.</p>
<p>The likely intended semantics are object identity: that an object is equal to itself. This is the behavior inherited from class <code>Object</code>. If you need to override an equals inherited from a different 
superclass, you can use use:
<pre>
public boolean equals(Object o) { return this == o; }
</pre>
</p><p>使用equals方法返回值总是false</p>
]]>
    </Details>
  </BugPattern>




  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
   <ShortDescription>Huge string constants is duplicated across multiple class files</ShortDescription>
   <LongDescription>{1} is initialized to a string constant {2} characters long that is duplicated in {3} other class files</LongDescription>
   <Details>
      <![CDATA[
      <p>
	A large String constant is duplicated across multiple class files. 
	This is likely because a final field is initialized to a String constant, and the Java language
	mandates that all references to a final field from other classes be inlined into
that classfile. See <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475">JDK bug 6447475</a>
	for a description of an occurrence of this bug in the JDK and how resolving it reduced
	the size of the JDK by 1 megabyte.
</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
   <ShortDescription>Method does not check for null argument</ShortDescription>
   <LongDescription>{1} does not check for null argument</LongDescription>
   <Details>
      <![CDATA[
      <p>
	A parameter to this method has been identified as a value that should
	always be checked to see whether or not it is null, but it is being dereferenced
	without a preceding null check.
      </p><p>方法没有判断参数是否为空</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
   <ShortDescription>equals() method does not check for null argument</ShortDescription>
   <LongDescription>{1} does not check for null argument</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This implementation of equals(Object) violates the contract defined
      by java.lang.Object.equals() because it does not check for null
      being passed as the argument.  All equals() methods should return
      false if passed a null value.
      </p><p>变量调用equals方法时没有进行是否为null的判断</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_DOES_NOT_HANDLE_NULL">
   <ShortDescription>equals() method does not check for null parameter</ShortDescription>
   <LongDescription>{1} does not check for null parameter</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This implementation of equals(Object) violates the contract defined
      by java.lang.Object.equals() because it does not check for null
      being passed as the parameter.  All equals() methods should return
      false if passed a null value.
      </p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>Covariant compareTo() method defined</ShortDescription>
    <LongDescription>{0} defines compareTo({0.givenClass}) method but not compareTo(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.</p><p>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：int compareTo(T o) ?比较此对象与指定对象的顺序。</p><p>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
    <ShortDescription>Signature declares use of unhashable class in hashed construct</ShortDescription>
    <LongDescription>{2} doesn't define a hashCode() method but it is used in a hashed context in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> A method, field or class declares a generic signature where a non-hashable class
is used in context where a hashable class is required.
A class that declares an equals method but inherits a hashCode() method
from Object is unhashable, since it doesn't fulfill the requirement that
equal objects have equal hashCodes.
</p><p>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn't fulfill the requirement that equal objects have equal hashCodes.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
    <ShortDescription>Use of class without a hashCode() method in a hashed data structure</ShortDescription>
    <LongDescription>{2} doesn't define a hashCode() method but is used in a hashed data structure</LongDescription>
    <Details>
<![CDATA[
  <p> A class defines an equals(Object)  method but not a hashCode() method,
and thus doesn't fulfill the requirement that equal objects have equal hashCodes.
An instance of this class is used in a hash data structure, making the need to
fix this problem of highest importance.<p>A class defines an equals(Object) method but not a hashCode() method, and thus doesn't fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>Class defines hashCode() and uses Object.equals()</ShortDescription>
    <LongDescription>{0} defines hashCode and uses Object.equals()</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but inherits its
  <code>equals()</code> method from <code>java.lang.Object</code>
  (which defines equality by comparing object references).&nbsp; Although
  this will probably satisfy the contract that equal objects must have
  equal hashcodes, it is probably not what was intended by overriding
  the <code>hashCode()</code> method.&nbsp; (Overriding <code>hashCode()</code>
  implies that the object's identity is based on criteria more complicated
  than simple reference equality.)</p>
<p>If you don't think instances of this class will ever be inserted into a HashMap/HashTable,
the recommended <code>hashCode</code> implementation to use is:</p>
<p><pre>public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do 
  }</pre></p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>Class defines compareTo(...) and uses Object.equals()</ShortDescription>
    <LongDescription>{0} defines {1.givenClass} and uses Object.equals()</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>compareTo(...)</code> method but inherits its
  <code>equals()</code> method from <code>java.lang.Object</code>.
	Generally, the value of compareTo should return zero if and only if
	equals returns true. If this is violated, weird and unpredictable
	failures will occur in classes such as PriorityQueue.
	In Java 5 the PriorityQueue.remove method uses the compareTo method,
	while in Java 6 it uses the equals method.

<p>From the JavaDoc for the compareTo method in the Comparable interface:
<blockquote>
It is strongly recommended, but not strictly required that <code>(x.compareTo(y)==0) == (x.equals(y))</code>. 
Generally speaking, any class that implements the Comparable interface and violates this condition 
should clearly indicate this fact. The recommended language 
is "Note: this class has a natural ordering that is inconsistent with equals."
</blockquote>
<p>
这个类重写了compareTo方法却没有重写equals方法。
我们应该遵从惯例：<code>(x.compareTo(y)==0) == (x.equals(y))</code>。
</p><p>类中定义了compareTo方法但是继承了Object中的compareTo方法</p>
]]>
    </Details>
  </BugPattern>




  <BugPattern type="HE_HASHCODE_NO_EQUALS">
    <ShortDescription>Class defines hashCode() but not equals()</ShortDescription>
    <LongDescription>{0} defines hashCode but not equals</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>hashCode()</code> method but not an
  <code>equals()</code> method.&nbsp; Therefore, the class may
  violate the invariant that equal objects must have equal hashcodes.</p><p>类定义了hashCode方法去没有定义equal方法</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>Class defines equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} defines equals and uses Object.hashCode()</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>, and inherits the implementation of
  <code>hashCode()</code> from <code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.</p>

<p>If you don't think instances of this class will ever be inserted into a HashMap/HashTable,
the recommended <code>hashCode</code> implementation to use is:</p>
<pre>public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do 
  }</pre>
  
  <p>
  这个类重写载了equals方法，却没有重写hashCode方法。如果使用java.lang.Object自己的hashCode，
  我们可以从JDK源代码可以看到object的hashCode方法是native的，它的值由虚拟机分配
  （某种情况下代表了在虚拟机中的地址或者唯一标识），每个对象都不一样。
  所以这很可能违反“Equals相等，hashcode一定相等；hashcode相等，equals不一定相等。”这一原则。
  除非你保证不运用到HashMap/HashTable等运用散列表查找值的数据结构中。否则，发生任何事情都是有可能的。
  </p><p>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
    <ShortDescription>Class inherits equals() and uses Object.hashCode()</ShortDescription>
    <LongDescription>{0} inherits equals and uses Object.hashCode()</LongDescription>
    <Details>
<![CDATA[
  <p> This class inherits <code>equals(Object)</code> from an abstract
  superclass, and <code>hashCode()</code> from
<code>java.lang.Object</code> (which returns
  the identity hash code, an arbitrary value assigned to the object
  by the VM).&nbsp; Therefore, the class is very likely to violate the
  invariant that equal objects must have equal hashcodes.</p>

  <p>If you don't want to define a hashCode method, and/or don't
   believe the object will ever be put into a HashMap/Hashtable,
   define the <code>hashCode()</code> method
   to throw <code>UnsupportedOperationException</code>.</p><p>子类继承了父类的equals方法却使用了Object的hashCode方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>Class defines equals() but not hashCode()</ShortDescription>
    <LongDescription>{0} defines equals but not hashCode</LongDescription>
    <Details>
<![CDATA[
  <p> This class overrides <code>equals(Object)</code>, but does not
  override <code>hashCode()</code>.&nbsp; Therefore, the class may violate the
  invariant that equal objects must have equal hashcodes.</p><p>方法定义了equals方法却没有定义hashCode方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>Abstract class defines covariant equals() method</ShortDescription>
    <LongDescription>Abstract {0} defines equals({0.givenClass}) method</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>equals()</code>.&nbsp;
  To correctly override the <code>equals()</code> method in
  <code>java.lang.Object</code>, the parameter of <code>equals()</code>
  must have type <code>java.lang.Object</code>.</p><p>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。</p><p></p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>Comparison of String objects using == or !=</ShortDescription>
    <LongDescription>Comparison of String objects using == or != in {1} </LongDescription>
    <Details>
<![CDATA[
  <p>This code compares <code>java.lang.String</code> objects for reference
equality using the == or != operators.
Unless both strings are either constants in a source file, or have been
interned using the <code>String.intern()</code> method, the same string
value may be represented by two different String objects. Consider
using the <code>equals(Object)</code> method instead.</p>
<p>
请使用<code>equals(Object)</code>来比较<code>java.lang.String</code>对象。
除非要比较的两个String都是常量，或者你使用了<code>String.intern()</code>方法，
否则同一个字符串会被两个<code>java.lang.String</code>对象代表，"=="会返回false。
</p><p>用==或者！=去比较String类型的对象</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
    <ShortDescription>Comparison of String parameter using == or !=</ShortDescription>
    <LongDescription>Comparison of String parameter using == or != in {1} </LongDescription>
    <Details>
<![CDATA[
  <p>This code compares a <code>java.lang.String</code> parameter for reference
equality using the == or != operators. Requiring callers to 
pass only String constants or interned strings to a method is unnecessarily
fragile, and rarely leads to measurable performance gains. Consider
using the <code>equals(Object)</code> method instead.</p><p>用==或者!=方法去比较String类型的参数</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>Abstract class defines covariant compareTo() method</ShortDescription>
    <LongDescription>Abstract {0} defines compareTo({0.givenClass}) method</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a covariant version of <code>compareTo()</code>.&nbsp;
  To correctly override the <code>compareTo()</code> method in the
  <code>Comparable</code> interface, the parameter of <code>compareTo()</code>
  must have type <code>java.lang.Object</code>.</p><p>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：int compareTo(T o) ?比较此对象与指定对象的顺序。</p><p>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>Field not guarded against concurrent access</ShortDescription>
    <LongDescription>{1.givenClass} not guarded against concurrent access; locked {2}% of time</LongDescription>
    <Details>
<![CDATA[
  <p> This field is annotated with net.jcip.annotations.GuardedBy, 
but can be accessed in a way that seems to violate the annotation.</p><p>域不是良好的同步访问---此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问</p>
]]>
</Details>
</BugPattern>

  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
    <ShortDescription>Mutable servlet field</ShortDescription>
    <LongDescription>{1} is a mutable servlet field</LongDescription>
    <Details>
<![CDATA[
<p>A web server generally only creates one instance of servlet or jsp class (i.e., treats
the class as a Singleton), 
and will 
have multiple threads invoke methods on that instance to service multiple 
simultaneous requests.
Thus, having a mutable instance field generally creates race conditions.<p>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>Inconsistent synchronization</ShortDescription>
    <LongDescription>Inconsistent synchronization of {1}; locked {2}% of time</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  </p>
  <ul>
  <li> The class contains a mix of locked and unlocked accesses,</li>
  <li> At least one locked access was performed by one of the class's own methods, and</li>
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads</li>
  </ul>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.</p>

  <p> You can select the nodes labeled "Unsynchronized access" to show the
  code locations where the detector believed that a field was accessed
  without synchronization.</p>

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.</p>

<p>
这个字段的同步存在不一致。
</p><p>不合理的同步</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
    <ShortDescription>Naked notify</ShortDescription>
    <LongDescription>Naked notify in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> A call to <code>notify()</code> or <code>notifyAll()</code>
  was made without any (apparent) accompanying
  modification to mutable object state.&nbsp; In general, calling a notify
  method on a monitor is done because some condition another thread is
  waiting for has become true.&nbsp; However, for the condition to be meaningful,
  it must involve a heap object that is visible to both threads.</p>

  <p> This bug does not necessarily indicate an error, since the change to
  mutable object state may have taken place in a method which then called
  the method containing the notification.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
    <ShortDescription>Public static method may expose internal representation by returning array</ShortDescription>
    <LongDescription>public static {1} may expose internal representation by returning {2.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p> A public static method returns a reference to
   an array that is part of the static state of the class.
   Any code that calls this method can freely modify
   the underlying array.
   One fix is to return a copy of the array.</p><p>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
    <ShortDescription>May expose internal representation by returning reference to mutable object</ShortDescription>
    <LongDescription>{1} may expose internal representation by returning {2.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p> Returning a reference to a mutable object value stored in one of the object's fields
  exposes the internal representation of the object.&nbsp;
   If instances
   are accessed by untrusted code, and unchecked changes to
   the mutable object would compromise security or other
   important properties, you will need to do something different.
  Returning a new copy of the object is better approach in many situations.</p>
<p>
返回一个内部字段的引用可能会使得内部信息被修改，存在安全隐患。建议返回一份内部字段的拷贝。
</p><p>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。</p><p>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>May expose internal representation by incorporating reference to mutable object</ShortDescription>
    <LongDescription>{1} may expose internal representation by storing an externally mutable object into {2.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p> This code stores a reference to an externally mutable object into the
  internal representation of the object.&nbsp;
   If instances
   are accessed by untrusted code, and unchecked changes to
   the mutable object would compromise security or other
   important properties, you will need to do something different.
  Storing a copy of the object is better approach in many situations.</p>
<p>
这段代码将一个外部可变的对象的引用赋给了一个内部字段，这样当外部对象被修改时，内部字段也会被悄悄修改，存在安全隐患。建议保存一份拷贝，而不是引用。
</p><p>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>May expose internal static state by storing a mutable object into a static field</ShortDescription>
    <LongDescription>{1} may expose internal static state by storing a mutable object into a static field {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This code stores a reference to an externally mutable object into a static
   field.
   If unchecked changes to
   the mutable object would compromise security or other
   important properties, you will need to do something different.
  Storing a copy of the object is better approach in many situations.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>Invokes run on a thread (did you mean to start it instead?)</ShortDescription>
    <LongDescription>{1} explicitly invokes run on a thread (did you mean to start it instead?)</LongDescription>
    <Details>
<![CDATA[
  <p> This method explicitly invokes <code>run()</code> on an object.&nbsp;
  In general, classes implement the <code>Runnable</code> interface because
  they are going to have their <code>run()</code> method invoked in a new thread,
  in which case <code>Thread.start()</code> is the right method to call.</p><p>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
    <ShortDescription>Method spins on field</ShortDescription>
    <LongDescription>Spinning on {2.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method spins in a loop which reads a field.&nbsp; The compiler
  may legally hoist the read out of the loop, turning the code into an
  infinite loop.&nbsp; The class should be changed so it uses proper
  synchronization (including wait and notify calls).</p><p>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
    <ShortDescription>Potentially dangerous use of non-short-circuit logic</ShortDescription>
    <LongDescription>Potentially dangerous use of non-short-circuit logic in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This code seems to be using non-short-circuit logic (e.g., &amp;
or |)
rather than short-circuit logic (&amp;&amp; or ||). In addition, 
it seem possible that, depending on the value of the left hand side, you might not
want to evaluate the right hand side (because it would have side effects, could cause an exception
or could be expensive.</p>
<p>
Non-short-circuit logic causes both sides of the expression
to be evaluated even when the result can be inferred from
knowing the left-hand side. This can be less efficient and
can result in errors if the left-hand side guards cases
when evaluating the right-hand side can generate an error.
</p>

<p>See <a href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the Java
Language Specification</a> for details

</p><p>代码中使用（& or |）代替（&& or ||）操作，这会造成潜在的危险。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>Questionable use of non-short-circuit logic</ShortDescription>
    <LongDescription>Questionable use of non-short-circuit logic in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This code seems to be using non-short-circuit logic (e.g., &amp;
or |)
rather than short-circuit logic (&amp;&amp; or ||).
Non-short-circuit logic causes both sides of the expression
to be evaluated even when the result can be inferred from
knowing the left-hand side. This can be less efficient and
can result in errors if the left-hand side guards cases
when evaluating the right-hand side can generate an error.

<p>See <a href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the Java
Language Specification</a> for details

</p><p>代码中使用（& or |）代替（&& or ||）操作，会引起不安全的操作</p>
]]>
    </Details>
  </BugPattern>




  <BugPattern type="TLW_TWO_LOCK_WAIT">
    <ShortDescription>Wait with two locks held</ShortDescription>
    <LongDescription>wait() with two locks held in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> Waiting on a monitor while two locks are held may cause
  deadlock.
   &nbsp;
   Performing a wait only releases the lock on the object
   being waited on, not any other locks.
   &nbsp;
This not necessarily a bug, but is worth examining
  closely.</p>
]]>
    </Details>
  </BugPattern>
   <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true"> <!-- never generated -->
    <ShortDescription>Notify with two locks held</ShortDescription>
    <LongDescription>notify() or notifyAll*() with two locks held in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The code calls notify() or notifyAll() while two locks
  are held. If this notification is intended to wake up a wait()
  that is holding the same locks, it may deadlock, since the wait
  will only give up one lock and the notify will be unable to get both locks,
  and thus the notify will not succeed.
   &nbsp; If there is also a warning about a two lock wait, the
   probably of a bug is quite high.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>Unconditional wait</ShortDescription>
    <LongDescription>Unconditional wait in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code> which
  is not guarded by conditional control flow.&nbsp; The code should
	verify that condition it intends to wait for is not already satisfied
	before calling wait; any previous notifications will be ignored.
  </p><p>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>Uninitialized read of field in constructor</ShortDescription>
    <LongDescription>Uninitialized read of {2.name} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This constructor reads a field which has not yet been assigned a value.&nbsp;
  This is often caused when the programmer mistakenly uses the field instead
  of one of the constructor's parameters.</p><p>此构造方法中使用了一个尚未赋值的字段或属性。String a;public SA() {String abc = a;System.out.println(abc);}</p><p>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：abstract class A {int hashCode;abstract Object getValue();A() {hashCode = getValue().hashCode();}}class B extends A {Object value;B(Object v) {this.value = v;}Object getValue() {return value;}}当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>Uninitialized read of field method called from constructor of superclass</ShortDescription>
    <LongDescription>{2.name} isn't initialized in {1} when invoked from constructor for superclass</LongDescription>
    <Details>
<![CDATA[
  <p> This method is invoked in the constructor of of the superclass. At this point,
	the fields of the class have not yet initialized.</p>
<p>To make this more concrete, consider the following classes:</p>
<pre>abstract class A {
  int hashCode;
  abstract Object getValue();
  A() {
    hashCode = getValue().hashCode();
    }
  }
class B extends A {
  Object value;
  B(Object v) {
    this.value = v;
    }
  Object getValue() {
    return value;
  }
  }</pre>
<p>When a <code>B</code> is constructed,
the constructor for the <code>A</code> class is invoked
<em>before</em> the constructor for <code>B</code> sets <code>value</code>.
Thus, when the constructor for <code>A</code> invokes <code>getValue</code>,
an uninitialized value is read for <code>value</code>
</p><p>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：abstract class A {int hashCode;abstract Object getValue();A() {hashCode = getValue().hashCode();}}class B extends A {Object value;B(Object v) {this.value = v;}Object getValue() {return value;}}当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>Unsynchronized get method, synchronized set method</ShortDescription>
    <LongDescription>{1} is unsynchronized, {2} is synchronized</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains similarly-named get and set
  methods where the set method is synchronized and the get method is not.&nbsp;
  This may result in incorrect behavior at runtime, as callers of the get
  method will not necessarily see a consistent state for the object.&nbsp;
  The get method should be made synchronized.</p><p>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IC_INIT_CIRCULARITY">
    <ShortDescription>Initialization circularity</ShortDescription>
    <LongDescription>Initialization circularity between {0} and {1}</LongDescription>
    <Details>
<![CDATA[
  <p> A circularity was detected in the static initializers of the two
  classes referenced by the bug instance.&nbsp; Many kinds of unexpected
  behavior may arise from such circularity.</p><p>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>Superclass uses subclass during initialization</ShortDescription>
    <LongDescription>Initialization of {0} accesses class {2}, which isn't initialized yet</LongDescription>
    <Details>
<![CDATA[
  <p> During the initialization of a class, the class makes an active use of a subclass.
That subclass will not yet be initialized at the time of this use.
For example, in the following code, <code>foo</code> will be null.</p>

<pre>
public class CircularClassInitialization {
	static class InnerClassSingleton extends CircularClassInitialization {
		static InnerClassSingleton singleton = new InnerClassSingleton();
	}
	
	static CircularClassInitialization foo = InnerClassSingleton.singleton;
}
</pre><p>子类在父类未初始化之前使用父类对象实例public class CircularClassInitialization {static class InnerClassSingleton extends CircularClassInitialization {static InnerClassSingleton singleton = new InnerClassSingleton();}static CircularClassInitialization foo = InnerClassSingleton.singleton;}</p>

]]>
    </Details>
  </BugPattern>



  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>Iterator next() method can't throw NoSuchElementException</ShortDescription>
    <LongDescription>{1} can't throw NoSuchElementException</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>java.util.Iterator</code> interface.&nbsp;
  However, its <code>next()</code> method is not capable of throwing
  <code>java.util.NoSuchElementException</code>.&nbsp; The <code>next()</code>
  method should be changed so it throws <code>NoSuchElementException</code>
  if is called when there are no more elements to return.</p><p>迭代器的next方法不能够抛出NoSuchElementException</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>Synchronization on interned String could lead to deadlock</ShortDescription>
    <LongDescription>Synchronization on interned String could deadlock in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The code synchronizes on interned String.
<pre>
private static String LOCK = "LOCK";
...
  synchronized(LOCK) { ...}
...
</pre>
</p>
<p>Constant Strings are interned and shared across all other classes loaded by the JVM. Thus, this could
is locking on something that other code might also be locking. This could result in very strange and hard to diagnose
blocking and deadlock behavior. See <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> and <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.
</p><p>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>Synchronization on Boolean could lead to deadlock</ShortDescription>
    <LongDescription>Synchronization on Boolean could deadlock in {1}</LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on a boxed primitive constant, such as an Boolean.
<pre>
private static Boolean inited = Boolean.FALSE;
...
  synchronized(inited) { 
    if (!inited) {
       init();
       inited = Boolean.TRUE;
       }
     }
...
</pre>
</p>
<p>Since there normally exist only two Boolean objects, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
and possible deadlock</p><p>该代码同步一个封装的原始常量，例如一个Boolean类型。private static Boolean inited = Boolean.FALSE;...synchronized(inited) {if (!inited) {init();inited = Boolean.TRUE;}}...由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>Synchronization on boxed primitive values</ShortDescription>
    <LongDescription>Synchronization on {2} in {1}</LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on an apparently unshared boxed primitive, 
such as an Integer.
<pre>
private static final Integer fileLock = new Integer(1);
...
  synchronized(fileLock) { 
     .. do something ..
     }
...
</pre>
</p>
<p>It would be much better, in this code, to redeclare fileLock as
<pre>
private static final Object fileLock = new Object();
</pre>
The existing code might be OK, but it is confusing and a 
future refactoring, such as the "Remove Boxing" refactoring in IntelliJ,
might replace this with the use of an interned Integer object shared 
throughout the JVM, leading to very confusing behavior and potential deadlock.
</p><p>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：private static final Integer fileLock = new Integer(1);...synchronized(fileLock) {.. do something ..}...它最后被定义为以下方式来代替：private static final Object fileLock = new Object();</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>Synchronization on boxed primitive could lead to deadlock</ShortDescription>
    <LongDescription>Synchronization on {2} could deadlock in {1}</LongDescription>
    <Details>
      <![CDATA[
  <p> The code synchronizes on a boxed primitive constant, such as an Integer.
<pre>
private static Integer count = 0;
...
  synchronized(count) { 
     count++;
     }
...
</pre>
</p>
<p>Since Integer objects can be cached and shared,
this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness
and possible deadlock</p><p>该代码同步一个封装的原始常量，例如一个Integer类型。private static Integer count = 0;...synchronized(count) {count++;}...由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>Empty synchronized block</ShortDescription>
    <LongDescription>Empty synchronized block in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The code contains an empty synchronized block:</p>
<pre>
synchronized() {}
</pre>
<p>Empty synchronized blocks are far more subtle and hard to use correctly
than most people recognize, and empty synchronized blocks
are almost never a better solution
than less contrived solutions.
</p><p>该代码包含一个空的同步块：synchronized() {}</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>Inconsistent synchronization</ShortDescription>
    <LongDescription>Inconsistent synchronization of {1}; locked {2}% of the time</LongDescription>
    <Details>
<![CDATA[
  <p> The fields of this class appear to be accessed inconsistently with respect
  to synchronization.&nbsp; This bug report indicates that the bug pattern detector
  judged that
  </p>
  <ul>
  <li> The class contains a mix of locked and unlocked accesses,</li>
  <li> At least one locked access was performed by one of the class's own methods, and</li>
  <li> The number of unsynchronized field accesses (reads and writes) was no more than
       one third of all accesses, with writes being weighed twice as high as reads</li>
  </ul>

  <p> A typical bug matching this bug pattern is forgetting to synchronize
  one of the methods in a class that is intended to be thread-safe.</p>

  <p> Note that there are various sources of inaccuracy in this detector;
  for example, the detector cannot statically detect all situations in which
  a lock is held.&nbsp; Also, even when the detector is accurate in
  distinguishing locked vs. unlocked accesses, the code in question may still
  be correct.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>Synchronization on field in futile attempt to guard that field</ShortDescription>
    <LongDescription>Synchronization on {2.givenClass} in futile attempt to guard it</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on a field in what appears to be an attempt
to guard against simultaneous updates to that field. But guarding a field
gets a lock on the referenced object, not on the field. This may not 
provide the mutual exclusion you need, and other threads might 
be obtaining locks on the referenced objects (for other purposes). An example
of this pattern would be:

<p><pre>
private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
     Long result = null;
     synchronized(myNtfSeqNbrCounter) {
         result = new Long(myNtfSeqNbrCounter.longValue() + 1);
         myNtfSeqNbrCounter = new Long(result.longValue());
     }
     return result;
 }
</pre>


</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>Method synchronizes on an updated field</ShortDescription>
    <LongDescription>{1} synchronizes on updated field {2.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p> This method synchronizes on an object
   referenced from a mutable field.
   This is unlikely to have useful semantics, since different
threads may be synchronizing on different objects.</p><p>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>Field should be moved out of an interface and made package protected</ShortDescription>
    <LongDescription>{1} should be moved out of an interface and made package protected</LongDescription>
    <Details>
<![CDATA[
<p>
 A final static field that is
defined in an interface references a mutable
   object such as an array or hashtable.
   This mutable object could
   be changed by malicious code or
        by accident from another package.
   To solve this, the field needs to be moved to a class
   and made package protected
   to avoid
        this vulnerability.</p><p>将域尽量不要定义在接口中，并声明为包保护在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>Field should be both final and package protected</ShortDescription>
    <LongDescription>{1} should be both final and package protected</LongDescription>
    <Details>
<![CDATA[
 <p>
   A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made package protected and/or made final
   to avoid
        this vulnerability.</p><p>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>Field isn't final but should be</ShortDescription>
    <LongDescription>{1} isn't final but should be</LongDescription>
    <Details>
<![CDATA[
   <p>
 A mutable static field could be changed by malicious code or
        by accident from another package.
        The field could be made final to avoid
        this vulnerability.</p>
<p>
这个静态字段很可能被恶意代码修改，应该为它补上final的声明。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
    <ShortDescription>Field should be package protected</ShortDescription>
    <LongDescription>{1} should be package protected</LongDescription>
    <Details>
<![CDATA[
  <p> A mutable static field could be changed by malicious code or
   by accident.
   The field could be made package protected to avoid
   this vulnerability.</p>
<p>
静态字段应该是包权限的。应该将其声明为private，以防被包外的代码而已修改。
</p><p>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
    <ShortDescription>Field is a mutable Hashtable</ShortDescription>
    <LongDescription>{1} is a mutable Hashtable</LongDescription>
    <Details>
<![CDATA[
 <p>A final static field references a Hashtable
   and can be accessed by malicious code or
        by accident from another package.
   This code can freely modify the contents of the Hashtable.</p><p>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
    <ShortDescription>Field is a mutable array</ShortDescription>
    <LongDescription>{1} is a mutable array</LongDescription>
    <Details>
<![CDATA[
<p> A final static field references an array
   and can be accessed by malicious code or
        by accident from another package.
   This code can freely modify the contents of the array.</p><p>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
    <ShortDescription>Field isn't final and can't be protected from malicious code</ShortDescription>
    <LongDescription>{1} isn't final and can't be protected from malicious code </LongDescription>
    <Details>
<![CDATA[
  <p>
 A mutable static field could be changed by malicious code or
        by accident from another package.
   Unfortunately, the way the field is used doesn't allow
   any easy fix to this problem.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>Ambiguous invocation of either an inherited or outer method</ShortDescription>
    <LongDescription>Ambiguous invocation of either an outer or inherited method {2} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> An inner class is invoking a method that could be resolved to either a inherited method or a method defined in an outer class. By the Java semantics,
it will be resolved to invoke the inherited method, but this may not be want
you intend. If you really intend to invoke the inherited method,
invoke it by invoking the method on super (e.g., invoke super.foo(17)), and
thus it will be clear to other readers of your code and to FindBugs
that you want to invoke the inherited method, not the method in the outer class.
</p>
<p>
这个内部类调用了一个它的父类和它的外部类都有的方法，有点模凌两可。
如果想调用父类的方法（假设方法名是<code>foo()</code>），那么使用<code>super.foo();</code>，
如果想使用外部类的<code>foo()</code>，使用<code>OutterClassName.this.foo();</code>。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>Class names shouldn't shadow simple name of superclass</ShortDescription>
    <LongDescription>The class name {0} shadows the simple name of the superclass {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This class has a simple name that is identical to that of its superclass, except
that its superclass is in a different package (e.g., <code>alpha.Foo</code> extends <code>beta.Foo</code>). 
This can be exceptionally confusing, create lots of situations in which you have to look at import statements
to resolve references and creates many
opportunities to accidently define methods that do not override methods in their superclasses.
</p><p>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
    <ShortDescription>Class names shouldn't shadow simple name of implemented interface</ShortDescription>
    <LongDescription>The class name {0} shadows the simple name of implemented interface {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This class/interface has a simple name that is identical to that of an implemented/extended interface, except
that the interface is in a different package (e.g., <code>alpha.Foo</code> extends <code>beta.Foo</code>). 
This can be exceptionally confusing, create lots of situations in which you have to look at import statements
to resolve references and creates many
opportunities to accidently define methods that do not override methods in their superclasses.
</p><p>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>Class names should start with an upper case letter</ShortDescription>
    <LongDescription>The class name {0} doesn't start with an upper case letter</LongDescription>
    <Details>
<![CDATA[
  <p> Class names should be nouns, in mixed case with the first letter of each internal word capitalized. Try to keep your class names simple and descriptive. Use whole words-avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the long form, such as URL or HTML).
</p>
<p>
类名的首字母应该大写！
</p><p>类的名称以大写字母名称开头</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>Method names should start with a lower case letter</ShortDescription>
    <LongDescription>The method name {1} doesn't start with a lower case letter</LongDescription>
    <Details>
<![CDATA[
  <p>
Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
</p>
<p>
方法名应该是动词，第一个单词的首字母小写，其他内部单词的首字母大写。
</p><p>方法名称以小写字母开头</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>Field names should start with a lower case letter</ShortDescription>
    <LongDescription>The field name {1} doesn't start with a lower case letter</LongDescription>
    <Details>
<![CDATA[
  <p>
Names of fields that are not final should be in mixed case with a lowercase first letter and the first letters of subsequent words capitalized.
</p>
<p>
字段名称应该以小写开头。
</p><p>非final类型的字段需要遵循驼峰命名原则</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>Very confusing method names</ShortDescription>
    <LongDescription>VERY confusing to have methods {1} and {3}</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization. 
This is very confusing because if the capitalization were
identical then one of the methods would override the other.
</p><p>混乱的方法命名，如getName和getname方法同时出现的时候</p><p>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
    <ShortDescription>Very confusing method names (but perhaps intentional)</ShortDescription>
    <LongDescription>VERY confusing (but perhaps intentional) to have methods {1} and {3}</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization. 
This is very confusing because if the capitalization were
identical then one of the methods would override the other. From the existence of other methods, it
seems that the existence of both of these methods is intentional, but is sure is confusing. 
You should try hard to eliminate one of them, unless you are forced to have both due to frozen APIs.
</p><p>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} doesn't override method in superclass because parameter type {4} doesn't match superclass parameter type {5}</LongDescription>
    <Details>
<![CDATA[
  <p> The method in the subclass doesn't override a similar method in a superclass because the type of a parameter doesn't exactly match
the type of the corresponding parameter in the superclass. For example, if you have:</p>

<blockquote>
<pre>
import alpha.Foo;
public class A {
  public int f(Foo x) { return 17; }
}
----
import beta.Foo;
public class B extends A {
  public int f(Foo x) { return 42; }
}
</pre>
</blockquote>

<p>The <code>f(Foo)</code> method defined in class <code>B</code> doesn't
override the 
<code>f(Foo)</code> method defined in class <code>A</code>, because the argument
types are <code>Foo</code>'s from different packages.
</p><p>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法import alpha.Foo;public class A {public int f(Foo x) { return 17; }}----import beta.Foo;public class B extends A {public int f(Foo x) { return 42; }}</p><p>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法import alpha.Foo;public class A {public int f(Foo x) { return 17; }}import beta.Foo;public class B extends A {public int f(Foo x) { return 42; }public int f(alpha.Foo x) { return 27; }}</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
    <ShortDescription>Method doesn't override method in superclass due to wrong package for parameter</ShortDescription>
    <LongDescription>{1} doesn't override method in superclass because parameter type {4} doesn't match superclass parameter type {5}</LongDescription>
    <Details>
<![CDATA[
  <p> The method in the subclass doesn't override a similar method in a superclass because the type of a parameter doesn't exactly match
the type of the corresponding parameter in the superclass. For example, if you have:</p>

<blockquote>
<pre>
import alpha.Foo;
public class A {
  public int f(Foo x) { return 17; }
}
----
import beta.Foo;
public class B extends A {
  public int f(Foo x) { return 42; }
  public int f(alpha.Foo x) { return 27; }
}
</pre>
</blockquote>

<p>The <code>f(Foo)</code> method defined in class <code>B</code> doesn't
override the 
<code>f(Foo)</code> method defined in class <code>A</code>, because the argument
types are <code>Foo</code>'s from different packages.
</p>

<p>In this case, the subclass does define a method with a signature identical to the method in the superclass,
so this is presumably understood. However, such methods are exceptionally confusing. You should strongly consider
removing or deprecating the method with the similar but not identical signature.
</p><p>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法import alpha.Foo;public class A {public int f(Foo x) { return 17; }}import beta.Foo;public class B extends A {public int f(Foo x) { return 42; }public int f(alpha.Foo x) { return 27; }}</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="NM_CONFUSING">
    <ShortDescription>Confusing method names</ShortDescription>
    <LongDescription>Confusing to have methods {1} and {3}</LongDescription>
    <Details>
<![CDATA[
  <p> The referenced methods have names that differ only by capitalization.</p>
  <p>
  同一个包两个类中有一模一样的两个方法（包括参数），最好修改为不同的名称。
  </p><p>令人迷惑的方面命名</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>Apparent method/constructor confusion</ShortDescription>
    <LongDescription>Method {1} was probably intended to be a constructor</LongDescription>
    <Details>
<![CDATA[
  <p> This regular method has the same name as the class it is defined in. It is likely that this was intended to be a constructor.
      If it was intended to be a constructor, remove the declaration of a void return value.
	If you had accidently defined this method, realized the mistake, defined a proper constructor
	but can't get rid of this method due to backwards compatibility, deprecate the method.
</p><p>构造方法定义混乱，保证一个标准的构造函数。	例如：SA(){}void SA(){}</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>Class defines hashcode(); should it be hashCode()?</ShortDescription>
    <LongDescription>Class {0} defines hashcode(); should it be hashCode()?</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>hashcode()</code>.&nbsp; This method
  does not override the <code>hashCode()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.</p><p>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
    <ShortDescription>Class defines tostring(); should it be toString()?</ShortDescription>
    <LongDescription>Class {0} defines tostring(); should it be toString()?</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a method called <code>tostring()</code>.&nbsp; This method
  does not override the <code>toString()</code> method in <code>java.lang.Object</code>,
  which is probably what was intended.</p><p>类中定义了一个toString方法但是却不是覆写的Object中的toString方法</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_BAD_EQUAL">
    <ShortDescription>Class defines equal(Object); should it be equals(Object)?</ShortDescription>
    <LongDescription>Class {0} defines equal(Object); should it be equals(Object)?</LongDescription>
    <Details>
<![CDATA[
<p> This class defines a method <code>equal(Object)</code>.&nbsp; This method does
not override the <code>equals(Object)</code> method in <code>java.lang.Object</code>,
which is probably what was intended.</p><p>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>Class is not derived from an Exception, even though it is named as such</ShortDescription>
    <LongDescription>Class {0} is not derived from an Exception, even though it is named as such</LongDescription>
    <Details>
<![CDATA[
<p> This class is not derived from another exception, but ends with 'Exception'. This will
be confusing to users of this class.</p><p>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>Method ignores results of InputStream.read()</ShortDescription>
    <LongDescription>{1} ignores result of {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method ignores the return value of one of the variants of
  <code>java.io.InputStream.read()</code> which can return multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were read than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  reads from input streams usually do read the full amount of data requested,
  causing the program to fail only sporadically.</p><p>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>Method ignores results of InputStream.skip()</ShortDescription>
    <LongDescription>{1} ignores result of {2}</LongDescription>
    <Details>
<![CDATA[
  <p> This method ignores the return value of
  <code>java.io.InputStream.skip()</code> which can skip multiple bytes.&nbsp;
  If the return value is not checked, the caller will not be able to correctly
  handle the case where fewer bytes were skipped than the caller requested.&nbsp;
  This is a particularly insidious kind of bug, because in many programs,
  skips from input streams usually do skip the full amount of data requested,
  causing the program to fail only sporadically. With Buffered streams, however,
  skip() will only skip data in the buffer, and will routinely fail to skip the
  requested number of bytes.</p><p>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
    <ShortDescription>The readResolve method must not be declared as a static method.  </ShortDescription>
    <LongDescription>{1} should be declared as an instance method rather than a static method</LongDescription>
    <Details>
<![CDATA[
  <p> In order for the readResolve method to be recognized by the serialization
mechanism, it must not be declared as a static method.
</p><p>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>private readResolve method not inherited by subclasses</ShortDescription>
    <LongDescription>private readResolve method in {0} not inherited by subclasses.</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a private readResolve method. Since it is private, it won't be inherited by subclasses.
This might be intentional and OK, but should be reviewed to ensure it is what is intended.
</p><p>声明为private的序列化方法被子类继承</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>The readResolve method must be declared with a return type of Object. </ShortDescription>
    <LongDescription>The method {1} must be declared with a return type of Object rather than {1.returnType}</LongDescription>
    <Details>
<![CDATA[
  <p> In order for the readResolve method to be recognized by the serialization
mechanism, it must be declared to have a return type of Object.
</p><p>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription>Transient field of class that isn't Serializable. </ShortDescription>
    <LongDescription>{1.givenClass} is transient but {0} isn't Serializable</LongDescription>
    <Details>
<![CDATA[
  <p> The field is marked as transient, but the class isn't Serializable, so marking it as transient
has absolutely no effect. 
This may be leftover marking from a previous version of the code in which the class was transient, or
it may indicate a misunderstanding of how serialization works.
</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription>Transient field that isn't set by deserialization. </ShortDescription>
    <LongDescription>The field {1} is transient but isn't set by deserialization</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any 
deserialized instance of the class.
</p><p>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
    <ShortDescription>Method must be private in order for serialization to work</ShortDescription>
    <LongDescription>The method {1.givenClass} must be private to be invoked in serialization/deserialization of {0}</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface, and defines a method
  for custom serialization/deserialization. But since that method isn't declared private,
  it will be silently ignored by the serialization/deserialization API.</p><p>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
    <ShortDescription>Class is Externalizable but doesn't define a void constructor</ShortDescription>
    <LongDescription>{0} is Externalizable but doesn't define a void constructor</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Externalizable</code> interface, but does
  not define a void constructor. When Externalizable objects are deserialized,
   they first need to be constructed by invoking the void
   constructor. Since this class does not have one,
   serialization and deserialization will fail at runtime.</p><p>Externalizable 实例类没有定义一个void类型的构造函数</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>Class is Serializable but its superclass doesn't define a void constructor</ShortDescription>
    <LongDescription>{0} is Serializable but its superclass doesn't define an accessible void constructor</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface
   and its superclass does not. When such an object is deserialized,
   the fields of the superclass need to be initialized by
   invoking the void constructor of the superclass.
   Since the superclass does not have one,
   serialization and deserialization will fail at runtime.</p><p>子类序列化时父类没有提供一个void的构造函数</p><p>Externalizable 实例类没有定义一个void类型的构造函数</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>Class is Serializable, but doesn't define serialVersionUID</ShortDescription>
    <LongDescription>{0} is Serializable; consider declaring a serialVersionUID</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Serializable</code> interface, but does
  not define a <code>serialVersionUID</code> field.&nbsp;
  A change as simple as adding a reference to a .class object
    will add synthetic fields to the class,
   which will unfortunately change the implicit
   serialVersionUID (e.g., adding a reference to <code>String.class</code>
   will generate a static field <code>class$java$lang$String</code>).
   Also, different source code to bytecode compilers may use different
   naming conventions for synthetic variables generated for
   references to class objects or inner classes.
   To ensure interoperability of Serializable across versions,
   consider adding an explicit serialVersionUID.</p>
   
   <p>
   实现了Serializable接口，却没有实现定义serialVersionUID字段，序列化的时候，我们的对象都保存为硬盘上的一个文件，
   当通过网络传输或者其他类加载方式还原为一个对象时，serialVersionUID字段会保证这个对象的兼容性，考虑两种情况：</p>
   <ul>
	<li>1. 新软件读取老文件，如果新软件有新的数据定义，那么它们必然会丢失。</li>
	<li>2. 老软件读取新文件，只要数据是向下兼容的，就没有任何问题。</li>
   </ul>
   <p>
   序列化会把所有与你要序列化对象相关的引用（包括父类，特别是内部类持有对外部类的引用，这里的例子就符合这种情况）
   都输出到一个文件中，这也是为什么能够使用序列化能进行深拷贝。这种序列化算法给我们的忠告是，不要把一些你无法确定
   其基本数据类型的对象引用作为你序列化的字段（比如JFrame），否则序列化后的文件超大，而且会出现意想不到的异常。
   </p><p>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 java.io 中的类InvalidClassException。可序列化类可以通过声明名为 "serialVersionUID" 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>Comparator doesn't implement Serializable</ShortDescription>
    <LongDescription>{0} implements Comparator but not Serializable</LongDescription>
    <Details>
<![CDATA[
  <p> This class implements the <code>Comparator</code> interface. You
should consider whether or not it should also implement the <code>Serializable</code>
interface. If a comparator is used to construct an ordered collection
such as a <code>TreeMap</code>, then the <code>TreeMap</code>
will be serializable only if the comparator is also serializable.
As most comparators have little or no state, making them serializable
is generally easy and good defensive programming.
</p>
<p>
类实现了Comparator接口却没有实现Serializable接口。因为像TreeMap这种可序列化数据结构（它实现了Serializable接口）
只有当比较器继承了Serializable接口时，它才能被序列化。<br/>
请实现Serializable接口并定义serialVersionUID字段。
</p><p>Comparator接口没有实现Serializable接口</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SF_SWITCH_FALLTHROUGH">
   <ShortDescription>Switch statement found where one case falls through to the next case</ShortDescription>
   <LongDescription>Switch statement found in {1} where one case falls through to the next case</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a switch statement where one case branch will fall through to the next case.
  Usually you need to end this case with a break or return.</p><p>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
   <ShortDescription>Switch statement found where default case is missing</ShortDescription>
   <LongDescription>Switch statement found in {1} where default case is missing</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a switch statement where default case is missing.
  Usually you need to provide a default case.</p><p>Switch没有默认情况下执行的case语句。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
   <ShortDescription>Dead store due to switch statement fall through</ShortDescription>
   <LongDescription>Value of {2.givenClass} from previous case is overwritten here due to switch statement fall through</LongDescription>
    <Details>
<![CDATA[
  <p> A value stored in the previous switch case is overwritten here due to a switch fall through. It is likely that
	you forgot to put a break or return at the end of the previous case.
</p><p>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。</p><p>在swtich中因为出现异常而忽略了对case值的保存。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
   <ShortDescription>Dead store due to switch statement fall through to throw</ShortDescription>
   <LongDescription>Value of {2.givenClass} from previous case is lost here due to switch statement fall through to throw</LongDescription>
    <Details>
<![CDATA[
  <p> A value stored in the previous switch case is ignored here due to a switch fall through to a place where
	an exception is thrown. It is likely that
	you forgot to put a break or return at the end of the previous case.
</p><p>在swtich中因为出现异常而忽略了对case值的保存。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>Class's writeObject() method is synchronized but nothing else is</ShortDescription>
    <LongDescription>{0}'s writeObject method is synchronized but nothing else is</LongDescription>
    <Details>
<![CDATA[
  <p> This class has a <code>writeObject()</code> method which is synchronized;
  however, no other method of the class is synchronized.</p><p>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
    <ShortDescription>Class's readObject() method is synchronized</ShortDescription>
    <LongDescription>{0}'s readObject method is synchronized</LongDescription>
    <Details>
<![CDATA[
  <p> This serializable class defines a <code>readObject()</code> which is
  synchronized.&nbsp; By definition, an object created by deserialization
  is only reachable by one thread, and thus there is no need for
  <code>readObject()</code> to be synchronized.&nbsp; If the <code>readObject()</code>
  method itself is causing the object to become visible to another thread,
  that is an example of very dubious coding style.</p><p>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't static</ShortDescription>
    <LongDescription>{1} isn't static</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not static.&nbsp;
  The field should be made static
   if it is intended to specify
   the version UID for purposes of serialization.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't final</ShortDescription>
    <LongDescription>{1} isn't final</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not final.&nbsp;
  The field should be made final
   if it is intended to specify
   the version UID for purposes of serialization.</p><p>关于UID类的检查内容省略</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID isn't long</ShortDescription>
    <LongDescription>{1} isn't long</LongDescription>
    <Details>
<![CDATA[
  <p> This class defines a <code>serialVersionUID</code> field that is not long.&nbsp;
  The field should be made long
   if it is intended to specify
   the version UID for purposes of serialization.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>Non-transient non-serializable instance field in serializable class</ShortDescription>
    <LongDescription>Class {0} defines non-transient non-serializable instance field {1.name}</LongDescription>
    <Details>
<![CDATA[
<p> This Serializable class defines a non-primitive instance field which is neither transient,
Serializable, or <code>java.lang.Object</code>, and does not appear to implement
the <code>Externalizable</code> interface or the
<code>readObject()</code> and <code>writeObject()</code> methods.&nbsp;
Objects of this class will not be deserialized correctly if a non-Serializable
object is stored in this field.</p><p>非序列化的值保存在声明为序列化的的非序列化字段中</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>Non-serializable class has a serializable inner class</ShortDescription>
    <LongDescription>{0} is serializable but also an inner class of a non-serializable class</LongDescription>
    <Details>
<![CDATA[
<p> This Serializable class is an inner class of a non-serializable class.
Thus, attempts to serialize it will also attempt to associate instance of the outer
class with which it is associated, leading to a runtime error.
</p>
<p>If possible, making the inner class a static inner class should solve the 
problem. Making the outer class serializable might also work, but that would
mean serializing an instance of the inner class would always also serialize the instance
of the outer class, which it often not what you really want.
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>Serializable inner class</ShortDescription>
    <LongDescription>{0} is serializable and an inner class</LongDescription>
    <Details>
<![CDATA[
<p> This Serializable class is an inner class.  Any attempt to serialize
it will also serialize the associated outer instance. The outer instance is serializable,
so this won't fail, but it might serialize a lot more data than intended.
If possible, making the inner class a static inner class (also known as a nested class) should solve the 
problem.<p>序列化内部类</p> 
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>Non-serializable value stored into instance field of a serializable class</ShortDescription>
    <LongDescription>{2} stored into non-transient field {1.givenClass}</LongDescription>
    <Details>
<![CDATA[
<p> A non-serializable value is stored into a non-transient field
of a serializable class.</p><p>非序列化的值保存在声明为序列化的的非序列化字段中</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>Constructor invokes Thread.start()</ShortDescription>
    <LongDescription>{1} invokes {2}</LongDescription>
    <Details>
<![CDATA[
  <p> The constructor starts a thread. This is likely to be wrong if
   the class is ever extended/subclassed, since the thread will be started
   before the subclass constructor is started.</p>
   
   <p>
   不要在构造方法中新启线程，可以提供init方法，其他方法根据实际情况而定。
   </p><p>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>Unread field: should this field be static?</ShortDescription>
    <LongDescription>Unread field: {1}; should this field be static?</LongDescription>
    <Details>
<![CDATA[
  <p> This class contains an instance final field that
   is initialized to a compile-time static value.
   Consider making the field static.</p>
   <p>
   这个final成员被初始化为一个static成员，建议将这个final成员声明为static的。
   </p><p>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
    <ShortDescription>Unused field</ShortDescription>
    <LongDescription>Unused field: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never used.&nbsp; Consider removing it from the class.</p><p>类中定义的属性从未被使用，建议删除。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>Unread field</ShortDescription>
    <LongDescription>Unread field: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never read.&nbsp; Consider removing it from the class.</p><p>类中定义的属性从未被调用，建议删除。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>Complicated, subtle or wrong increment in for-loop </ShortDescription>
    <LongDescription>Complicated, subtle or wrong increment in for-loop {1} </LongDescription>
    <Details>
<![CDATA[
   <p>Are you sure this for loop is incrementing the correct variable?
   It appears that another variable is being initialized and checked
   by the for loop.
</p><p>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>Field only ever set to null</ShortDescription>
    <LongDescription>Field only ever set to null: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> All writes to this field are of the constant value null, and thus
all reads of the field will return null.
Check for errors, or remove it if it is useless.</p>
<p>
这个字段的值永远为null，如果没用应该将它删除。
</p><p>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>Unwritten field</ShortDescription>
    <LongDescription>Unwritten field: {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never written.&nbsp; All reads of it will return the default
value. Check for errors (should it have been initialized?), or remove it if it is useless.</p><p>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>Write to static field from instance method</ShortDescription>
    <LongDescription>Write to static field {2} from instance method {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This instance method writes to a static field. This is tricky to get
correct if multiple instances are being manipulated,
and generally bad practice.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
    <ShortDescription>Load of known null value</ShortDescription>
    <LongDescription>Load of known null value in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The variable referenced at this point is known to be null due to an earlier
   check against null. Although this is valid, it might be a mistake (perhaps you
intended to refer to a different variable, or perhaps the earlier check to see if the
variable is null should have been a check to see if it was nonnull).
</p>
<p>
这个变量在之前已经被检测过是否为空，但又被重复检查了一次。你想检查的是否是另一个变量？
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>Dereference of the result of readLine() without nullcheck</ShortDescription>
    <LongDescription>Dereference of the result of readLine() without nullcheck in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The result of invoking readLine() is dereferenced without checking to see if the result is null. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p><p>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
    <ShortDescription>Immediate dereference of the result of readLine()</ShortDescription>
    <LongDescription>Immediate dereference of the result of readLine() in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The result of invoking readLine() is immediately dereferenced. If there are no more lines of text
to read, readLine() will return null and dereferencing that will generate a null pointer exception.
</p><p>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>Read of unwritten field</ShortDescription>
    <LongDescription>Read of unwritten field {2.name} in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> The program is dereferencing a field that does not seem to ever have a non-null value written to it.
Dereferencing this value will generate a null pointer exception.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>Deadly embrace of non-static inner class and thread local</ShortDescription>
    <LongDescription>{0} needs to be _static_ to avoid a deadly embrace with {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but should probably be a static inner class.
  As it is, there is a serious danger of a deadly embrace between the inner class
  and the thread local in the outer class. Because the inner class isn't static,
  it retains a reference to the outer class. 
  If the thread local contains a reference to an instance of the inner
  class, the inner and outer instance will both be reachable
  and not eligible for garbage collection.
</p><p>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>Should be a static inner class</ShortDescription>
    <LongDescription>Should {0} be a _static_ inner class?</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
   made static.
</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="NP_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR" deprecated="true">  <!-- deprecated in favor of UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR -->
    <ShortDescription>Read of field not initialized in constructor</ShortDescription>
    <LongDescription>Read of field not initialized in constructor at {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This is a read of a field is never initialized within any constructor, and is therefore could be null after
the object is initialized. This might be a coding error, or else the class containing the field
is written in a way that depends upon methods being called in some specific order (a little bit dodgy,
but not necessarily wrong).
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>Field not initialized in constructor</ShortDescription>
    <LongDescription>{1.givenClass} not initialized in constructor</LongDescription>
    <Details>
<![CDATA[
  <p> This field is never initialized within any constructor, and is therefore could be null after
the object is constructed.
This could be a either an error or a questionable design, since
it means a null pointer exception will be generated if that field is dereferenced
before being initialized.
</p><p>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>Could be refactored into a named static inner class</ShortDescription>
    <LongDescription>The class {0} could be refactored into a named _static_ inner class</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class. Since anonymous inner
classes cannot be marked as static, doing this will require refactoring
the inner class so that it is a named inner class.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>Could be refactored into a static inner class</ShortDescription>
    <LongDescription>The class {0} could be refactored into a _static_ inner class</LongDescription>
    <Details>
<![CDATA[
  <p> This class is an inner class, but does not use its embedded reference
  to the object which created it except during construction of the
inner object.&nbsp; This reference makes the instances
  of the class larger, and may keep the reference to the creator object
  alive longer than necessary.&nbsp; If possible, the class should be
  made into a <em>static</em> inner class. Since the reference to the
   outer object is required during construction of the inner instance,
   the inner class will need to be refactored so as to
   pass a reference to the outer instance to the constructor
   for the inner class.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>Wait not in loop </ShortDescription>
    <LongDescription>Wait not in loop in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.lang.Object.wait()</code>
  which is not in a loop.&nbsp; If the monitor is used for multiple conditions,
  the condition the caller intended to wait for might not be the one
  that actually occurred.</p><p>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>Condition.await() not in loop </ShortDescription>
    <LongDescription>Condition.await() not in loop in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method contains a call to <code>java.util.concurrent.await()</code>
   (or variants)
  which is not in a loop.&nbsp; If the object is used for multiple conditions,
  the condition the caller intended to wait for might not be the one
  that actually occurred.</p><p>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
    <ShortDescription>Using notify() rather than notifyAll()</ShortDescription>
    <LongDescription>Using notify rather than notifyAll in {1}</LongDescription>
    <Details>
<![CDATA[
  <p> This method calls <code>notify()</code> rather than <code>notifyAll()</code>.&nbsp;
  Java monitors are often used for multiple conditions.&nbsp; Calling <code>notify()</code>
  only wakes up one thread, meaning that the thread woken up might not be the
  one waiting for the condition that the caller just satisfied.</p><p>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>Method checks to see if result of String.indexOf is positive</ShortDescription>
    <LongDescription>{1} checks to see if result of String.indexOf is positive</LongDescription>
    <Details>
<![CDATA[
   <p> The method invokes String.indexOf and checks to see if the result is positive or non-positive.
   It is much more typical to check to see if the result is negative or non-negative. It is
   positive only if the substring checked for occurs at some place other than at the beginning of
   the String.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>Method discards result of readLine after checking if it is nonnull</ShortDescription>
    <LongDescription>{1} discards result of readLine after checking if it is nonnull</LongDescription>
    <Details>
<![CDATA[
   <p> The value returned by readLine is discarded after checking to see if the return
value is non-null. In almost all situations, if the result is non-null, you will want
to use that non-null value. Calling readLine again will give you a different line.</p><p>readLine方法的结果不为空时被抛弃</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>Method ignores return value</ShortDescription>
    <LongDescription>{1} ignores return value of {2}</LongDescription>
    <Details>
<![CDATA[
   <p> The return value of this method should be checked. One common
cause of this warning is to invoke a method on an immutable object,
thinking that it updates the object. For example, in the following code
fragment,</p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>
</blockquote>
<p>the programmer seems to be thinking that the trim() method will update
the String referenced by dateString. But since Strings are immutable, the trim()
function returns a new String value, which is being ignored here. The code
should be corrected to: </p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString = dateString.trim();
</pre>
</blockquote>
<p>
方法的返回值应该得到检查。导致这个警告出现的常见原因是调用一个不可变类的对象的某个方法，企图更新这个对象。
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>
</blockquote>
例如，上面这段代码调用用<code>dateString.trim()</code>后，并不会改变<code>dateString</code>的值，而是返回一个新的对象。
</p><p>方法忽略返回值的异常信息</p><p>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);dateString.trim();程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：String dateString = getHeaderField(name);dateString = dateString.trim();</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>Method ignores exceptional return value</ShortDescription>
    <LongDescription>{1} ignores exceptional return value of {2}</LongDescription>
    <Details>
<![CDATA[
   <p> This method returns a value that is not checked. The return value should be checked
since it can indicate an unusual or unexpected function execution. For
example, the <code>File.delete()</code> method returns false
if the file could not be successfully deleted (rather than 
throwing an Exception).
If you don't check the result, you won't notice if the method invocation
signals unexpected behavior by returning an atypical return value.
</p>
<p>
应该检查这个方法的返回值，以判断方法是否执执行成功。因为这个方法使用返回值而不是抛出异常来告知方法是否执行成功。
</p><p>方法忽略返回值的异常信息</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
    <ShortDescription>Exception created and dropped rather than thrown</ShortDescription>
    <LongDescription>{1} forgets to throw {2.givenClass}</LongDescription>
    <Details>
<![CDATA[
   <p> This code creates an exception (or error) object, but doesn't do anything with it. For example,
something like </p>
<blockquote>
<pre>
if (x &lt; 0)
  new IllegalArgumentException("x must be nonnegative");
</pre>
</blockquote>
<p>It was probably the intent of the programmer to throw the created exception:</p>
<blockquote>
<pre>
if (x &lt; 0)
  throw new IllegalArgumentException("x must be nonnegative");
</pre>
</blockquote>
<p>
这段代码new了一个异常对象，但却没有抛出它。
</p><p>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x < 0)new IllegalArgumentException("x must be nonnegative");这可能是程序员的意图抛出创建的异常：if (x < 0)throw new IllegalArgumentException("x must be nonnegative");</p>
]]>

    </Details>
  </BugPattern>



  <BugPattern type="RV_RETURN_VALUE_IGNORED2">
    <ShortDescription>Method ignores return value</ShortDescription>
    <LongDescription>{1} ignores return value of {2}</LongDescription>
    <Details>
<![CDATA[
   <p> The return value of this method should be checked. One common
cause of this warning is to invoke a method on an immutable object,
thinking that it updates the object. For example, in the following code
fragment,</p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>
</blockquote>
<p>the programmer seems to be thinking that the trim() method will update
the String referenced by dateString. But since Strings are immutable, the trim()
function returns a new String value, which is being ignored here. The code
should be corrected to: </p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString = dateString.trim();
</pre>
</blockquote>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>Null pointer dereference</ShortDescription>
    <LongDescription>Null pointer dereference of {2.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> A null pointer is dereferenced here.&nbsp; This will lead to a
<code>NullPointerException</code> when the code is executed.</p>
<p>
这个空指针被解引用了，这将导致<code>NullPointerException</code>被抛出。
</p><p>对象赋为null值后 没有被重新赋值</p><p>A pointer which is null on an exception path is dereferenced here.? This will lead to a NullPointerException when the code is executed.? Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.空指针引用上调用去除引用方法，将发生空指针异常</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>close() invoked on a value that is always null</ShortDescription>
    <LongDescription>Can't close {2.givenClass} since it is always null in {1}</LongDescription>
    <Details>
<![CDATA[
<p> close() is being invoked on a value that is always null. If this statement is executed,
a null pointer exception will occur. But the big risk here you never close
something that should be closed.<p>一个为空的对象调用close方法</p> 
]]>
    </Details>
  </BugPattern>


  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
    <ShortDescription>Store of null value into field annotated NonNull</ShortDescription>
    <LongDescription>Store of null value into field {2.givenClass} annotated NonNull at {1}</LongDescription>
    <Details>
      <![CDATA[
<p> A value that could be null is stored into a field that has been annotated as NonNull. </p><p>为一个已经声明为不能为null值的属性赋值为null。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>Null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>Null pointer dereference of {2.givenClass} in {1} on exception path</LongDescription>
    <Details>
<![CDATA[
<p> A pointer which is null on an exception path is dereferenced here.&nbsp;
This will lead to a <code>NullPointerException</code> when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p><p>A pointer which is null on an exception path is dereferenced here.? This will lead to a NullPointerException when the code is executed.? Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.空指针引用上调用去除引用方法，将发生空指针异常</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
    <ShortDescription>Parameter must be nonnull but is marked as nullable</ShortDescription>
    <LongDescription>{2} must be nonnull but is marked as nullable</LongDescription>
    <Details>
<![CDATA[
<p> This parameter is always used in a way that requires it to be nonnull,
but the parameter is explicitly annotated as being Nullable. Either the use
of the parameter or the annotation is wrong.
</p><p>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>Possible null pointer dereference</ShortDescription>
    <LongDescription>Possible null pointer dereference of {2.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> There is a branch of statement that, <em>if executed,</em>  guarantees that
a null value will be dereferenced, which
would generate a <code>NullPointerException</code> when the code is executed.
Of course, the problem might be that the branch or statement is infeasible and that
the null pointer exception can't ever be executed; deciding that is beyond the ability of FindBugs.
</p>
<p>
这段代码中存在对空指针解引用的分支。如果这个分支被执行，必将抛出<code><code>NullPointerException</code>。
</p><p>对象可能没有重新赋值</p><p>A reference value which is null on some exception control path is dereferenced here.? This may lead to a NullPointerException when the code is executed.? Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.在异常null值处理分支调用的方法上，可能存在对象去除引用操作</p><p>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>Possible null pointer dereference on path that might be infeasible</ShortDescription>
    <LongDescription>Possible null pointer dereference of {2.givenClass} on path that might be infeasible in {1}</LongDescription>
    <Details>
<![CDATA[
<p> There is a branch of statement that, <em>if executed,</em>  guarantees that
a null value will be dereferenced, which
would generate a <code>NullPointerException</code> when the code is executed.
Of course, the problem might be that the branch or statement is infeasible and that
the null pointer exception can't ever be executed; deciding that is beyond the ability of FindBugs.
Due to the fact that this value had been previously tested for nullness, this is a definite possibility.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
    <ShortDescription>Possible null pointer dereference in method on exception path</ShortDescription>
    <LongDescription>Possible null pointer dereference of {2.givenClass} in {1} on exception path</LongDescription>
    <Details>
<![CDATA[
<p> A reference value which is null on some exception control path is
dereferenced here.&nbsp; This may lead to a <code>NullPointerException</code>
when the code is executed.&nbsp;
Note that because FindBugs currently does not prune infeasible exception paths,
this may be a false warning.</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p><p>A reference value which is null on some exception control path is dereferenced here.? This may lead to a NullPointerException when the code is executed.? Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.在异常null值处理分支调用的方法上，可能存在对象去除引用操作</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
   <ShortDescription>Possible null pointer dereference due to return value of called method</ShortDescription>
   <LongDescription>Possible null pointer dereference in {1} due to return value of called method</LongDescription>
   <Details>
      <![CDATA[
<p> The return value from a method is dereferenced without a null check,
and the return value of that method is one that should generally be checked
for null.  This may lead to a <code>NullPointerException</code> when the code is executed.
</p><p>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
   <ShortDescription>Non-virtual method call passes null for nonnull parameter</ShortDescription>
   <LongDescription>Non-virtual method call in {1} passes null for nonnull parameter of {2.givenClass}</LongDescription>
   <Details>
      <![CDATA[
      <p>
      A possibly-null value is passed to a nonnull method parameter.
	Either the parameter is annotated as a parameter that should
	always be nonnull, or analysis has shown that it will always be 
	dereferenced.
      </p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
   <ShortDescription>Method call passes null for nonnull parameter</ShortDescription>
   <LongDescription>Method call in {1} passes null for nonnull parameter of {2.givenClass}</LongDescription>
   <Details>
      <![CDATA[
      <p>
      A possibly-null value is passed at a call site where all known
      target methods require the parameter to be nonnull.
	Either the parameter is annotated as a parameter that should
	always be nonnull, or analysis has shown that it will always be 
	dereferenced.
      </p><p>方法参数中声明为nonnull类型的参数为nullvoid test(){String ss = null;sya(ss);}public void sya(@nonnull String ad){ad.getBytes();}</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_PARAM_DEREF">
   <ShortDescription>Method call passes null for nonnull parameter</ShortDescription>
   <LongDescription>Method call in {1} passes null for nonnull parameter of {2.givenClass}</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method call passes a null value for a nonnull method parameter.
	Either the parameter is annotated as a parameter that should
	always be nonnull, or analysis has shown that it will always be 
	dereferenced.
      </p>
<p>
这个调用使用了一个可能为空的参数值，而被调用的方法参数值是不可为空的。
</p><p>方法参数中声明为nonnull类型的参数为nullvoid test(){String ss = null;sya(ss);}public void sya(@nonnull String ad){ad.getBytes();}</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
   <ShortDescription>Method call passes null to a nonnull parameter </ShortDescription>
   <LongDescription>Method call in {1} passes null to a nonnull parameter of {2.givenClass}</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method passes a null value as the parameter of a method which
	must be nonnull. Either this parameter has been explicitly marked
	as @Nonnull, or analysis has determined that this parameter is
	always dereferenced.
      </p><p>方法中为null的参数没有被重新赋值void test(){String ss = null;sya(ss);}public void sya(String ad){ad.getBytes();}</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
   <ShortDescription>Method may return null, but is declared @NonNull</ShortDescription>
   <LongDescription>Method {1} may return null, but is declared @NonNull</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method may return a null value, but the method (or a superclass method
      which it overrides) is declared to return @NonNull.
      </p><p>方法声明了返回值不能为空，但是方法中有可能返回null</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
   <ShortDescription>Clone method may return null</ShortDescription>
   <LongDescription>{1} may return null</LongDescription>
   <Details>
      <![CDATA[
      <p>
	This clone method seems to return null in some circumstances, but clone is never
	allowed to return a null value.  If you are convinced this path is unreachable, throw an AssertionError
	instead.
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
   <ShortDescription>toString method may return null</ShortDescription>
   <LongDescription>{1} may return null</LongDescription>
   <Details>
      <![CDATA[
      <p>
	This toString method seems to return null in some circumstances. A liberal reading of the
	spec could be interpreted as allowing this, but it is probably a bad idea and could cause
	other code to break. Return the empty string or some other appropriate string rather than null.
      </p><p>toString方法可能返回null</p>
      ]]>
   </Details>
  </BugPattern>
	
	
  <BugPattern type="NP_GUARANTEED_DEREF">
	  <ShortDescription>Null value is guaranteed to be dereferenced</ShortDescription>
	  <LongDescription>{2.givenClass} could be null and is guaranteed to be dereferenced in {1}</LongDescription>
	  <Details>
		  <![CDATA[
			  <p>
			  There is a statement or branch that if executed guarantees that
			  a value is null at this point, and that 
			  value that is guaranteed to be dereferenced
			  (except on forward paths involving runtime exceptions).
			  </p><p>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).在正常的null判断分支上，对象去除引用操作是受保护的不允许的</p><p>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).</p>
		  ]]>
	  </Details>
  </BugPattern>
  
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
	  <ShortDescription>Value is null and guaranteed to be dereferenced on exception path</ShortDescription>
	  <LongDescription>{2.name} is null guaranteed to be dereferenced in {1} on exception path</LongDescription>
	  <Details>
		  <![CDATA[
			  <p>
			  There is a statement or branch on an exception path
				that if executed guarantees that
			  a value is null at this point, and that 
			  value that is guaranteed to be dereferenced
			  (except on forward paths involving runtime exceptions).
			  </p><p>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).</p>
		  ]]>
	  </Details>
  </BugPattern>

  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>Static initializer creates instance before all static final fields assigned</ShortDescription>
    <LongDescription>Static initializer for {0} creates instance before all static final fields assigned</LongDescription>
    <Details>
<![CDATA[
<p> The class's static initializer creates an instance of the class
before all of the static final fields are assigned.</p><p>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>Method may fail to close stream</ShortDescription>
    <LongDescription>{1} may fail to close stream</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods that might close it, 
or return it, and does not appear to close
the stream on all paths out of the method.&nbsp; This may result in
a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p><p>方法中可能存在关闭流失败的情况</p><p>方法中可能存在关闭流时出现异常情况</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>Method may fail to close stream on exception</ShortDescription>
    <LongDescription>{1} may fail to close stream on exception</LongDescription>
    <Details>
<![CDATA[
<p> The method creates an IO stream object, does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
it on all possible exception paths out of the method.&nbsp;
This may result in a file descriptor leak.&nbsp; It is generally a good
idea to use a <code>finally</code> block to ensure that streams are
closed.</p><p>方法中可能存在关闭流时出现异常情况</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>Consider returning a zero length array rather than null</ShortDescription>
    <LongDescription>Should {1} return a zero length array rather than null?</LongDescription>
    <Details>
<![CDATA[
<p> It is often a better design to
return a length zero array rather than a null reference to indicate that there
are no results (i.e., an empty list of results).
This way, no explicit check for null is needed by clients of the method.</p>

<p>On the other hand, using null to indicate
"there is no answer to this question" is probably appropriate.
For example, <code>File.listFiles()</code> returns an empty list
if given a directory containing no files, and returns null if the file
is not a directory.</p><p>考虑返回一个零长度的数组，而不是null值</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>Useless control flow</ShortDescription>
    <LongDescription>Useless control flow in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement, where
control flow continues onto the same place regardless of whether or not
the branch is taken. For example,
this is caused by having an empty statement
block for an <code>if</code> statement:</p>
<pre>
    if (argv.length == 0) {
	// TODO: handle this case
	}
</pre><p>没有任何作用的条件语句。if (argv.length == 0) {// TODO: handle this case}</p><p>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。if (argv.length == 1);System.out.println("Hello, " + argv[0]);</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>Useless control flow to next line</ShortDescription>
    <LongDescription>Useless control flow to next line in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a useless control flow statement in which control
flow follows to the same or following line regardless of whether or not
the branch is taken.
Often, this is caused by inadvertently using an empty statement as the
body of an <code>if</code> statement, e.g.:</p>
<pre>
    if (argv.length == 1);
        System.out.println("Hello, " + argv[0]);
</pre><p>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。if (argv.length == 1);System.out.println("Hello, " + argv[0]);</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>Nullcheck of value previously dereferenced</ShortDescription>
    <LongDescription>Nullcheck of {2.givenClass} at {4.lineNumber} of value previously dereferenced in {1}</LongDescription>
    <Details>
<![CDATA[
<p> A value is checked here to see whether it is null, but this value can't
be null because it was previously dereferenced and if it were null a null pointer
exception would have occurred at the earlier dereference. 
Essentially, this code and the previous dereference
disagree as to whether this value is allowed to be null. Either the check is redundant
or the previous dereference is erroneous.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>Redundant nullcheck of value known to be null</ShortDescription>
    <LongDescription>Redundant nullcheck of {2} which is known to be null in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant check of a known null value against
the constant null.</p>
<p>
这个方法对一个已知的null值进行了多余的判断。
</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>Redundant nullcheck of value known to be non-null</ShortDescription>
    <LongDescription>Redundant nullcheck of {2}, which is known to be non-null in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant check of a known non-null value against
the constant null.</p>
<p>
这段代码对一个已知的非空值进行检测，这是多余的。
</p><p>方法中对不为空的值进行为空的判断。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
    <ShortDescription>Redundant comparison of two null values</ShortDescription>
    <LongDescription>Redundant comparison of two null values in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant comparison of two references known to
both be definitely null.</p><p>方法中对两个null值进行比较</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
    <ShortDescription>Redundant comparison of non-null value to null</ShortDescription>
    <LongDescription>Redundant comparison of non-null value to null in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a reference known to be non-null with another reference
known to be null.</p><p>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true">   <!-- deprecated in favor of two separate RCN_ patterns -->
    <ShortDescription>Redundant comparison to null of previously checked value</ShortDescription>
    <LongDescription>Redundant comparison to null of previously checked {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a redundant comparison of a reference value
to null. Two types of redundant comparison are reported:
</p>
<ul>
<li> Both values compared are definitely null</li>
<li> One value is definitely null and the other is definitely not null</li>
</ul>

<p> This particular warning generally indicates that a
value known not to be null was checked against null.
While the check is not necessary, it may simply be a case
of defensive programming.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK">
    <ShortDescription>Method does not release lock on all paths</ShortDescription>
    <LongDescription>{1} does not release lock on all paths</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
</p>
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre><p>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：Lock l = ...;l.lock();try {// do something} finally {l.unlock();}</p><p>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：Lock l = ...;l.lock();try {// do something} finally {l.unlock();}</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>Method does not release lock on all exception paths</ShortDescription>
    <LongDescription>{1} does not release lock on all exception paths</LongDescription>
    <Details>
<![CDATA[
<p> This method acquires a JSR-166 (<code>java.util.concurrent</code>) lock,
but does not release it on all exception paths out of the method.  In general, the correct idiom
for using a JSR-166 lock is:
</p>
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre><p>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：Lock l = ...;l.lock();try {// do something} finally {l.unlock();}</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>Suspicious reference comparison</ShortDescription>
    <LongDescription>Suspicious comparison of {2} references in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares two reference values using the == or != operator,
where the correct way to compare instances of this type is generally
with the equals() method. 
It is possible to create distinct instances that are equal but do not compare as == since
they are different objects.
Examples of classes which should generally
not be compared by reference are java.lang.Integer, java.lang.Float, etc.</p><p>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float</p><p>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。</p><p>比较两个对象值是否相等时应该采用equals方法，而不是==方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>Suspicious reference comparison to constant</ShortDescription>
    <LongDescription>Suspicious comparison of a {2} reference to constant in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares a reference value to a constant using the == or != operator,
where the correct way to compare instances of this type is generally
with the equals() method.  
It is possible to create distinct instances that are equal but do not compare as == since
they are different objects.
Examples of classes which should generally
not be compared by reference are java.lang.Integer, java.lang.Float, etc.</p><p>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float</p><p>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>Suspicious reference comparison of Boolean values</ShortDescription>
    <LongDescription>Suspicious comparison of Boolean references in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares two Boolean values using the == or != operator. 
Normally, there are only two Boolean values (Boolean.TRUE and Boolean.FALSE),
but it is possible to create other Boolean objects using the <code>new Boolean(b)</code>
constructor. It is best to avoid such objects, but if they do exist,
then checking Boolean objects for equality using == or != will give results
than are different than you would get using <code>.equals(...)</code>
</p><p>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>Using pointer equality to compare different types</ShortDescription>
    <LongDescription>Using pointer equality to compare a {2.givenClass} with a {3.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method uses using pointer equality to compare two references that seem to be of
different types.  The result of this comparison will always be false at runtime.
</p><p>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>Call to equals() comparing different types</ShortDescription>
    <LongDescription>Call to equals() comparing different types in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object) on two references of different
class types with no common subclasses.
Therefore, the objects being compared
are unlikely to be members of the same class at runtime
(unless some application classes were not analyzed, or dynamic class
loading can occur at runtime).
According to the contract of equals(),
objects of different
classes should always compare as unequal; therefore, according to the
contract defined by java.lang.Object.equals(Object),
the result of this comparison will always be false at runtime.
</p>
<p>
两个不同类型的对象调用equals，将永远返回false，除非你重写了equals方法。
</p><p>调用equals方法比较不同类型的类</p><p>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>Call to equals() comparing different interface types</ShortDescription>
    <LongDescription>Call to equals() comparing different interface types in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object) on two references of unrelated
interface types, where neither is a subtype of the other,
and there are no known non-abstract classes which implement both interfaces.
Therefore, the objects being compared
are unlikely to be members of the same class at runtime
(unless some application classes were not analyzed, or dynamic class
loading can occur at runtime).
According to the contract of equals(),
objects of different
classes should always compare as unequal; therefore, according to the
contract defined by java.lang.Object.equals(Object),
the result of this comparison will always be false at runtime.
</p><p>调用equals方法比较不同类型的接口</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
   <ShortDescription>Call to equals() comparing unrelated class and interface</ShortDescription>
   <LongDescription>Call to equals() comparing unrelated class and interface in {1}</LongDescription>
   <Details>
      <![CDATA[
<p>
This method calls equals(Object) on two references,  one of which is a class
and the other an interface, where neither the class nor any of its
non-abstract subclasses implement the interface.
Therefore, the objects being compared
are unlikely to be members of the same class at runtime
(unless some application classes were not analyzed, or dynamic class
loading can occur at runtime).
According to the contract of equals(),
objects of different
classes should always compare as unequal; therefore, according to the
contract defined by java.lang.Object.equals(Object),
the result of this comparison will always be false at runtime.
</p><p>使用equals方法比较不相关的类和接口</p>
      ]]>
   </Details>
  </BugPattern>


  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>Call to equals() with null argument</ShortDescription>
    <LongDescription>Call to equals() with null argument in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls equals(Object), passing a null value as
the argument. According to the contract of the equals() method,
this call should always return <code>false</code>.</p><p>调用equals的对象为null</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>Mismatched wait()</ShortDescription>
    <LongDescription>Mismatched wait() in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.wait() without obviously holding a lock
on the object.&nbsp;  Calling wait() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.</p><p>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>Mismatched notify()</ShortDescription>
    <LongDescription>Mismatched notify() in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method calls Object.notify() or Object.notifyAll() without obviously holding a lock
on the object.&nbsp;  Calling notify() or notifyAll() without a lock held will result in
an <code>IllegalMonitorStateException</code> being thrown.</p><p>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>Self assignment of local variable</ShortDescription>
    <LongDescription>Self assignment of local variable in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a local variable; e.g.</p>
<pre>
  public void foo() {
    int x = 3;
    x = x;
  }
</pre>
<p>
Such assignments are useless, and may indicate a logic error or typo.
</p><p>局部变量使用自身给自己赋值public void foo() {int x = 3;x = x;}</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>Self assignment of field</ShortDescription>
    <LongDescription>Self assignment of field {2.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a self assignment of a field; e.g.
</p>
<pre>
  int x;
  public void foo() {
    x = x;
  }
</pre>
<p>Such assignments are useless, and may indicate a logic error or typo.</p><p>方法中包含自己对自己赋值的字段。例如：int x;public void foo() {x = x;}</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>Double assignment of field</ShortDescription>
    <LongDescription>Double assignment of field {2.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a double assignment of a field; e.g.
</p>
<pre>
  int x,y;
  public void foo() {
    x = x = 17;
  }
</pre>
<p>Assigning to a field twice is useless, and may indicate a logic error or typo.</p><p>方法中的字段包含了双重任务，例如：int x;public void foo() {x = x = 17;}这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>Double assignment of local variable </ShortDescription>
    <LongDescription>Double assignment of {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains a double assignment of a local variable; e.g.
</p>
<pre>
  public void foo() {
    int x,y;
    x = x = 17;
  }
</pre>
<p>Assigning the same value to a variable twice is useless, and may indicate a logic error or typo.</p><p>为一个局部变量两次赋值，这样是没有意义的。例如：public void foo() {int x,y;x = x = 17;}</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
    <ShortDescription>Nonsensical self computation involving a field (e.g., x &amp; x)</ShortDescription>
    <LongDescription>Nonsensical self computation of {2.givenClass} with itself in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method performs a nonsensical computation of a field with another
reference to the same field (e.g., x&x or x-x). Because of the nature
of the computation, this operation doesn't seem to make sense,
and may indicate a typo or
a logic error.  Double check the computation.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription>Nonsensical self computation involving a variable (e.g., x &amp; x)</ShortDescription>
    <LongDescription>Nonsensical self computation of {2} with itself in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method performs a nonsensical computation of a local variable with another
reference to the same variable (e.g., x&x or x-x). Because of the nature
of the computation, this operation doesn't seem to make sense,
and may indicate a typo or
a logic error.  Double check the computation.
</p><p>此方法对同一变量执行了荒谬的计算（如x&x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>Self comparison of field with itself</ShortDescription>
    <LongDescription>Self comparison of {2.givenClass} with itself in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares a field with itself, and may indicate a typo or
a logic error.  Make sure that you are comparing the right things.
</p><p>字段自己进行自比较可能表明错误或逻辑错误。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>Self comparison of value with itself</ShortDescription>
    <LongDescription>Self comparison of {2} with itself {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares a local variable with itself, and may indicate a typo or
a logic error.  Make sure that you are comparing the right things.
</p><p>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>Double.longBitsToDouble invoked on an int</ShortDescription>
    <LongDescription>Double.longBitsToDouble invoked on an int in {1}</LongDescription>
    <Details>
<![CDATA[
<p> The Double.longBitsToDouble method is invoked, but a 32 bit int value is passed
	as an argument. This almostly certainly is not intended and is unlikely 
	to give the intended result.
</p><p></p>
]]>
    </Details>
  </BugPattern>




  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>Random object created and used only once</ShortDescription>
    <LongDescription>Random object created and used only once in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This code creates a java.util.Random object, uses it to generate one random number, and then discards
the Random object. This produces mediocre quality random numbers and is inefficient. 
If possible, rewrite the code so that the Random object is created once and saved, and each time a new random number
is required invoke a method on the existing Random object to obtain it.
</p>

<p>If it is important that the generated Random numbers not be guessable, you <em>must</em> not create a new Random for each random
number; the values are too easily guessable. You should strongly consider using a java.security.SecureRandom instead
(and avoid allocating a new SecureRandom for each random number needed).
</p><p>随机创建对象只使用过一次就抛弃</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>Bad attempt to compute absolute value of signed 32-bit random integer</ShortDescription>
    <LongDescription>Bad attempt to compute absolute value of signed 32-bit random integer in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This code generates a random signed integer and then computes
the absolute value of that random integer.  If the number returned by the random number
generator is <code>Integer.MIN_VALUE</code>, then the result will be negative as well (since 
<code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>).
</p><p>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>Bad attempt to compute absolute value of signed 32-bit hashcode </ShortDescription>
    <LongDescription>Bad attempt to compute absolute value of signed 32-bit hashcode in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This code generates a hashcode and then computes
the absolute value of that hashcode.  If the hashcode 
is <code>Integer.MIN_VALUE</code>, then the result will be negative as well (since 
<code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code>).
</p>
<p>One out of 2^32 strings have a hashCode of Integer.MIN_VALUE,
including "polygenelubricants" "GydZG_" and ""DESIGNING WORKHOUSES".
</p><p>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>Remainder of 32-bit signed random integer</ShortDescription>
    <LongDescription>Remainder of 32-bit signed random integer computed in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This code generates a random signed integer and then computes
the remainder of that value modulo another value. Since the random
number can be negative, the result of the remainder operation
can also be negative. Be sure this is intended, and strongly
consider using the Random.nextInt(int) method instead.
</p><p>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>Remainder of hashCode could be negative</ShortDescription>
    <LongDescription>Remainder of hashCode could be negative in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This code computes a hashCode, and then computes
the remainder of that value modulo another value. Since the hashCode
can be negative, the result of the remainder operation
can also be negative. </p>
<p> Assuming you want to ensure that the result of your computation is nonnegative,
you may need to change your code.
If you know the divisor is a power of 2,
you can use a bitwise and operator instead (i.e., instead of
using <code>x.hashCode()%n</code>, use <code>x.hashCode()&amp;(n-1)</code>. 
This is probably faster than computing the remainder as well.
If you don't know that the divisor is a power of 2, take the absolute
value of the result of the remainder operation (i.e., use
<code>Math.abs(x.hashCode()%n)</code>
</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
    <ShortDescription>Bad comparison of nonnegative value with negative constant</ShortDescription>
    <LongDescription>Bad comparison of nonnegative value with {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This code compares a value that is guaranteed to be non-negative with a negative constant.
</p><p>保证非负数和负数进行比较</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>Bad comparison of signed byte</ShortDescription>
    <LongDescription>Bad comparison of signed byte with {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> Signed bytes can only have a value in the range -128 to 127. Comparing
a signed byte with a value outside that range is vacuous and likely to be incorrect.
To convert a signed byte <code>b</code> to an unsigned value in the range 0..255,
use <code>0xff &amp; b</code>
</p><p>比较有符合数，要先把有符号数转换为无符合数再进行比较</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>Vacuous bit mask operation on integer value</ShortDescription>
    <LongDescription>Vacuous {2} operation on {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This is an integer bit operation (and, or, or exclusive or) that doesn't do any useful work
(e.g., <code>v & 0xffffffff</code>).

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>Vacuous comparison of integer value</ShortDescription>
    <LongDescription>Vacuous comparison of integer value {1} </LongDescription>
    <Details>
<![CDATA[
<p> There is an integer comparison that always returns
the same value (e.g., x &lt;= Integer.MAX_VALUE).
</p><p>整形数进行比较结果总是不变。例如：x <= Integer.MAX_VALUE</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>Integer remainder modulo 1</ShortDescription>
    <LongDescription>Integer remainder modulo 1 computed in {1} </LongDescription>
    <Details>
<![CDATA[
<p> Any expression (exp % 1) is guaranteed to always return zero.
Did you mean (exp &amp; 1) or (exp % 2) instead?
</p>
<p>
表达式没有意义。任何整数或整数表达式模1的结果永远为0 。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>Bitwise OR of signed byte value computed in {1} </LongDescription>
    <Details>
<![CDATA[
<p> Loads a value from a byte array and performs a bitwise OR with
that value. Values loaded from a byte array are sign extended to 32 bits
before any any bitwise operations are performed on the value.
Thus, if <code>b[0]</code> contains the value <code>0xff</code>, and
<code>x</code> is initially 0, then the code 
<code>((x &lt;&lt; 8) | b[0])</code>  will sign extend <code>0xff</code>
to get <code>0xffffffff</code>, and thus give the value
<code>0xffffffff</code> as the result.
</p>

<p>In particular, the following code for packing a byte array into an int is badly wrong: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
  result = ((result &lt;&lt; 8) | b[i]);
</pre>

<p>The following idiom will work instead: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
  result = ((result &lt;&lt; 8) | (b[i] &amp; 0xff));
</pre>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>Bitwise add of signed byte value</ShortDescription>
    <LongDescription>Bitwise add of signed byte value computed in {1} </LongDescription>
    <Details>
<![CDATA[
<p> Adds a byte value and a value which is known to the 8 lower bits clear.
Values loaded from a byte array are sign extended to 32 bits
before any any bitwise operations are performed on the value.
Thus, if <code>b[0]</code> contains the value <code>0xff</code>, and
<code>x</code> is initially 0, then the code 
<code>((x &lt;&lt; 8) + b[0])</code>  will sign extend <code>0xff</code>
to get <code>0xffffffff</code>, and thus give the value
<code>0xffffffff</code> as the result.
</p>

<p>In particular, the following code for packing a byte array into an int is badly wrong: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
  result = ((result &lt;&lt; 8) + b[i]);
</pre>

<p>The following idiom will work instead: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++) 
  result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));
</pre>

]]>
    </Details>
  </BugPattern>



  <BugPattern type="BIT_AND">
    <ShortDescription>Incompatible bit masks</ShortDescription>
    <LongDescription>Incompatible bit masks in (e &amp; {2} == {3}) yields a constant result in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression of the form (e &amp; C) to D,
which will always compare unequal
due to the specific values of constants C and D.
This may indicate a logic error or typo.</p><p>错误的使用&位操作符，例如(e & C)</p><p>检查恒等的逻辑错误</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>Check for sign of bitwise operation</ShortDescription>
    <LongDescription>Check for sign of bitwise operation in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression such as
<pre>((event.detail &amp; SWT.SELECTED) &gt; 0)</pre>.
Using bit arithmetic and then comparing with the greater than operator can
lead to unexpected results (of course depending on the value of
SWT.SELECTED). If SWT.SELECTED is a negative number, this is a candidate
for a bug. Even when SWT.SELECTED is not negative, it seems good practice
to use '!= 0' instead of '&gt; 0'.
</p>
<p>
<em>Boris Bokowski</em>
</p><p>检查逻辑运算符操作返回的标识。例如((event.detail & SWT.SELECTED) > 0)，建议采用!=0代替>0</p><p>检查位操作符运行是否合理((event.detail & SWT.SELECTED) > 0)If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use '!= 0' instead of '> 0'.</p><p>检查逻辑运算符操作返回的标识。例如((event.detail & SWT.SELECTED) > 0)，建议采用!=0代替>0</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>Check for sign of bitwise operation</ShortDescription>
    <LongDescription>Check for sign of bitwise operation in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression such as
<pre>((event.detail &amp; SWT.SELECTED) &gt; 0)</pre>.
Using bit arithmetic and then comparing with the greater than operator can
lead to unexpected results (of course depending on the value of
SWT.SELECTED). If SWT.SELECTED is a negative number, this is a candidate
for a bug. Even when SWT.SELECTED is not negative, it seems good practice
to use '!= 0' instead of '&gt; 0'.
</p>
<p>
<em>Boris Bokowski</em>
</p><p>检查逻辑运算符操作返回的标识。例如((event.detail & SWT.SELECTED) > 0)，建议采用!=0代替>0</p><p>检查位操作符运行是否合理((event.detail & SWT.SELECTED) > 0)If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use '!= 0' instead of '> 0'.</p><p>检查逻辑运算符操作返回的标识。例如((event.detail & SWT.SELECTED) > 0)，建议采用!=0代替>0</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>Check to see if ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>Check to see if ((...) &amp; 0) == 0 in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression of the form (e &amp; 0) to 0,
which will always compare equal.
This may indicate a logic error or typo.</p><p>检查恒等的逻辑错误</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BIT_IOR">
    <ShortDescription>Incompatible bit masks</ShortDescription>
    <LongDescription>Incompatible bit masks in (e | {2} == {3}) yields constant result in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method compares an expression of the form (e | C) to D.
which will always compare unequal
due to the specific values of constants C and D.
This may indicate a logic error or typo.</p>

<p> Typically, this bug occurs because the code wants to perform
a membership test in a bit set, but uses the bitwise OR
operator ("|") instead of bitwise AND ("&amp;").</p><p>错误的使用|位操作符，例如(e | C)</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true">  <!-- never generated? -->
    <ShortDescription>Incorrect lazy initialization of instance field</ShortDescription>
    <LongDescription>Incorrect lazy initialization of instance field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="LI_LAZY_INIT_STATIC">
    <ShortDescription>Incorrect lazy initialization of static field</ShortDescription>
    <LongDescription>Incorrect lazy initialization of static field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a non-volatile static field.
Because the compiler or processor may reorder instructions,
threads are not guaranteed to see a completely initialized object,
<em>if the method can be called by multiple threads</em>.
You can make the field volatile to correct the problem.
For more information, see the
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
<p>
这段代码包含了对静态字段的初始化，不是线程安全的。
</p><p>静态域不正确的延迟初始化--这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
    <ShortDescription>Incorrect lazy initialization and update of static field</ShortDescription>
    <LongDescription>Incorrect lazy initialization and update of static field {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p> This method contains an unsynchronized lazy initialization of a static field.
After the field is set, the object stored into that location is further updated or accessed.
The setting of the field is visible to other threads as soon as it is set. If the
futher accesses in the method that set the field serve to initialize the object, then
you have a <em>very serious</em> multithreading bug, unless something else prevents
any other thread from accessing the stored object until it is fully initialized.
</p>
<p>Even if you feel confident that the method is never called by multiple
threads, it might be better to not set the static field until the value
you are setting it to is fully populated/initialized.
<p>
这段代码包含了对静态字段的延迟初始化，不是线程安全的。
</p><p>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>Synchronization performed on Lock</ShortDescription>
    <LongDescription>Synchronization performed on {2} in {1}</LongDescription>
<Details>
<![CDATA[
<p> This method performs synchronization an object that implements
java.util.concurrent.locks.Lock. Such an object is locked/unlocked
using 
<code>acquire()</code>/<code>release()</code> rather
than using the <code>synchronized (...)</code> construct.
</p><p>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。</p>
]]>
</Details>
  </BugPattern>

  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>Synchronization performed on util.concurrent instance</ShortDescription>
    <LongDescription>Synchronization performed on {2} in {1}</LongDescription>
<Details>
<![CDATA[
<p> This method performs synchronization an object that is an instance of
a class from the java.util.concurrent package (or its subclasses). Instances
of these classes have there own concurrency control mechanisms that are distinct from
and incompatible with the use of the keyword <code>synchronized</code>.
</p>
]]>
</Details>
  </BugPattern>

  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>Private method is never called</ShortDescription>
    <LongDescription>Private method {1} is never called</LongDescription>
<Details>
<![CDATA[
<p> This private method is never called. Although it is
possible that the method will be invoked through reflection,
it is more likely that the method is never used, and should be
removed.
</p><p>定义为Private类型方法从未被调用，应该被删除。</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
    <ShortDescription>Uncallable method defined in anonymous class</ShortDescription>
    <LongDescription>Uncallable method {1} defined in anonymous class</LongDescription>
<Details>
<![CDATA[
<p> This anonymous class defined a method that is not directly invoked and does not override
a method in a superclass. Since methods in other classes cannot directly invoke methods
declared in an anonymous class, it seems that this method is uncallable. The method
might simply be dead code, but it is also possible that the method is intended to
override a method declared in a superclass, and due to an typo or other error the method does not,
in fact, override the method it is intended to.
</p><p>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。</p>
]]>
</Details>
  </BugPattern>

  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>Method may fail to close database resource</ShortDescription>
    <LongDescription>{1} may fail to close {2.excludingPackage}</LongDescription>
    <Details>
<![CDATA[
<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.
</p><p>方法中可能存在关闭数据连接失败的情况</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>Method may fail to close database resource on exception</ShortDescription>
    <LongDescription>{1} may fail to close database resource on exception</LongDescription>
    <Details>
<![CDATA[
<p> The method creates a database resource (such as a database connection
or row set), does not assign it to any
fields, pass it to other methods, or return it, and does not appear to close
the object on all exception paths out of the method.&nbsp; Failure to
close database resources on all paths out of a method may
result in poor performance, and could cause the application to
have problems communicating with the database.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>Method concatenates strings using + in a loop</ShortDescription>
    <LongDescription>Method {1} concatenates strings using + in a loop</LongDescription>
    <Details>
<![CDATA[
<p> The method seems to be building a String using concatenation in a loop.
In each iteration, the String is converted to a StringBuffer/StringBuilder,
   appended to, and converted back to a String.
   This can lead to a cost quadratic in the number of iterations,
   as the growing string is recopied in each iteration. </p>

<p>Better performance can be obtained by using
a StringBuffer (or StringBuilder in Java 1.5) explicitly.</p>

<p> For example:</p>
<pre>
  // This is bad
  String s = "";
  for (int i = 0; i &lt; field.length; ++i) {
    s = s + field[i];
  }

  // This is better
  StringBuffer buf = new StringBuffer();
  for (int i = 0; i &lt; field.length; ++i) {
    buf.append(field[i]);
  }
  String s = buf.toString();
</pre>
<p>
在每轮迭代中，String都被转为StringBuffer，增补字符，再转为String，非常低效。
建议每轮迭代中，在StringBuffer末尾增补字符。当迭代结束后，把StringBuffer转为String。
</p><p>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象例如：// This is badString s = "";for (int i = 0; i < field.length; ++i) {s = s + field[i];}// This is betterStringBuffer buf = new StringBuffer();for (int i = 0; i < field.length; ++i) {buf.append(field[i]);}String s = buf.toString();</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>Method uses toArray() with zero-length array argument</ShortDescription>
    <LongDescription>Method {1} uses Collection.toArray() with zero-length array argument</LongDescription>
    <Details>
<![CDATA[
<p> This method uses the toArray() method of a collection derived class, and passes
in a zero-length prototype array argument.  It is more efficient to use
<code>myCollection.toArray(new Foo[myCollection.size()])</code>
If the array passed in is big enough to store all of the
elements of the collection, then it is populated and returned
directly. This avoids the need to create a second array
(by reflection) to return as the result.</p><p>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>JUnit assertion in run method will not be noticed by JUnit</ShortDescription>
    <LongDescription>JUnit assertion in {1} will not be noticed by JUnit</LongDescription>
    <Details>
<![CDATA[
<p> A JUnit assertion is performed in a run method. Failed JUnit assertions
just result in exceptions being thrown.
Thus, if this exception occurs in a thread other than the thread that invokes
the test method, the exception will terminate the thread but not result
in the test failing.
</p><p>在JUnit中的断言在run方法中不会被告知</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
    <ShortDescription>TestCase defines setUp that doesn't call super.setUp()</ShortDescription>
    <LongDescription>TestCase {0} defines setUp that doesn't call super.setUp()</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and implements the setUp method. The setUp method should call
super.setUp(), but doesn't.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
    <ShortDescription>TestCase defines tearDown that doesn't call super.tearDown()</ShortDescription>
    <LongDescription>TestCase {0} defines tearDown that doesn't call super.tearDown()</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and implements the tearDown method. The tearDown method should call
super.tearDown(), but doesn't.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>TestCase implements a non-static suite method </ShortDescription>
    <LongDescription>TestCase {0} implements a non-static suite method</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and implements the suite() method.
 The suite method should be declared as being static, but isn't.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>TestCase declares a bad suite method </ShortDescription>
    <LongDescription>Bad declaration for suite method in {0}</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase and defines a suite() method.
However, the suite method needs to be declared as either
<pre>public static junit.framework.Test suite()</pre>
or 
<pre>public static junit.framework.TestSuite suite()</pre>
</p><p>在一个JUnit类中声明的一个suite()方法必须声明为public static junit.framework.Test suite()或者public static junit.framework.TestSuite suite()的形式。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IJU_NO_TESTS">
    <ShortDescription>TestCase has no tests</ShortDescription>
    <LongDescription>TestCase {0} has no tests</LongDescription>
    <Details>
<![CDATA[
<p> Class is a JUnit TestCase but has not implemented any test methods</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
    <ShortDescription>Class overrides a method implemented in super class Adapter wrongly</ShortDescription>
    <LongDescription>Class {0} overrides a method {1} implemented in super class Adapter wrongly</LongDescription>
    <Details>
<![CDATA[
<p> This method overrides a method found in a parent class, where that class is an Adapter that implements
a listener defined in the java.awt.event or javax.swing.event package. As a result, this method will not
get called when the event occurs.</p><p>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true">  <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>Method {1} attempts to access a result set field with index 0</LongDescription>
    <Details>
<![CDATA[
<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>Method attempts to access a result set field with index 0</ShortDescription>
    <LongDescription>Method {1} attempts to access a result set field with index 0</LongDescription>
    <Details>
<![CDATA[
<p> A call to getXXX or updateXXX methods of a result set was made where the
field index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>Method attempts to access a prepared statement parameter with index 0</ShortDescription>
    <LongDescription>Method {1} attempts to access a prepared statement parameter with index 0</LongDescription>
    <Details>
<![CDATA[
<p> A call to a setXXX method of a prepared statement was made where the
parameter index is 0. As parameter indexes start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>Unnecessary type check done using instanceof operator</ShortDescription>
    <LongDescription>Method {1} does an unnecessary type check using instanceof operator when it can be determined statically</LongDescription>
    <Details>
<![CDATA[
<p> Type check performed using the instanceof operator where it can be statically determined whether the object
is of the type requested. </p><p>在进行instanceof操作时进行没有必要的类型检查</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>Bad Applet Constructor relies on uninitialized AppletStub</ShortDescription>
    <LongDescription>Bad Applet Constructor relies on uninitialized AppletStub</LongDescription>
    <Details>
<![CDATA[
<p>
This constructor calls methods in the parent Applet that rely on the AppletStub. Since the AppletStub
isn't initialized until the init() method of this applet is called, these methods will not perform
correctly.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>equals() used to compare array and nonarray</ShortDescription>
    <LongDescription>{1} uses equals to compare an array and nonarray</LongDescription>
    <Details>
<![CDATA[
<p>
This method invokes the .equals(Object o) to compare an array and a reference that doesn't seem
to be an array. If things being compared are of different types, they are guaranteed to be unequal
and the comparison is almost certainly an error. Even if they are both arrays, the equals method
on arrays only determines of the two arrays are the same object.
To compare the
contents of the arrays, use java.util.Arrays.equals(Object[], Object[]).
</p><p>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
    <ShortDescription>Invocation of equals() on an array, which is equivalent to ==</ShortDescription>
    <LongDescription>{1} invokes equals() on an array, which is equivalent to ==</LongDescription>
    <Details>
<![CDATA[
<p>
This method invokes the .equals(Object o) method on an array. Since arrays do not override the equals
method of Object, calling equals on an array is the same as comparing their addresses. To compare the
contents of the arrays, use <code>java.util.Arrays.equals(Object[], Object[])</code>.
To compare the addresses of the arrays, it would be
less confusing to explicitly pointer equality using <code>==</code>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>equals(...) used to compare incompatible arrays</ShortDescription>
    <LongDescription>{1} uses equals to compare a {2} and a {3}</LongDescription>
    <Details>
<![CDATA[
<p>
This method invokes the .equals(Object o) to compare two arrays, but the arrays of
of incompatible types (e.g., String[] and StringBuffer[], or String[] and int[]).
They will never be equal. In addition, when equals(...) is used to compare arrays it
only checks to see if they are the same array, and ignores the contents of the arrays.
</p><p>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="UOE_USE_OBJECT_EQUALS">
    <ShortDescription>Calls to equals on a final class that doesn't override Object's equals method</ShortDescription>
    <LongDescription>Calls to equals on a final class that doesn't override Object's equals method</LongDescription>
    <Details>
<![CDATA[
<p>
This method invokes the .equals(Object o) method on a final class that doesn't override the equals method
in the Object class, effectively making the equals method test for sameness, like ==. It is good to use
the .equals method, but you should consider adding an .equals method in this class.
</p>
<p>[Bill Pugh]: Sorry, but I strongly disagree that this should be a warning, and I think your code
is just fine. Users of your code shouldn't care how you've implemented equals(), and they should never
depend on == to compare instances, since that bypasses the libraries ability to control how objects
are compared.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>Unneeded use of currentThread() call, to call interrupted() </ShortDescription>
    <LongDescription>Method {1} makes an unneeded call to currentThread() just to call interrupted()</LongDescription>
    <Details>
<![CDATA[
<p>
This method invokes the Thread.currentThread() call, just to call the interrupted() method. As interrupted() is a
static method, is more simple and clear to use Thread.interrupted().
</p><p>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>Static Thread.interrupted() method invoked on thread instance</ShortDescription>
    <LongDescription>{1} invokes static Thread.interrupted() method on thread instance</LongDescription>
    <Details>
<![CDATA[
<p>
This method invokes the Thread.interrupted() method on a Thread object that appears to be a Thread object that is
not the current thread. As the interrupted() method is static, the interrupted method will be called on a different
object than the one the author intended.
</p><p>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
    <ShortDescription>A parameter is dead upon entry to a method but overwritten</ShortDescription>
    <LongDescription>The parameter {2} to {1} is dead upon entry but overwritten</LongDescription>
    <Details>
<![CDATA[
<p>
The initial value of this parameter is ignored, and the parameter
is overwritten here. This often indicates a mistaken belief that
the write to the parameter will be conveyed back to
the caller.
</p><p>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>Dead store to local variable</ShortDescription>
    <LongDescription>Dead store to {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This instruction assigns a value to a local variable,
but the value is not read or used in any subsequent instruction.
Often, this indicates an error, because the value computed is never
used.
</p>
<p>
Note that Sun's javac compiler often generates dead stores for
final local variables.  Because FindBugs is a bytecode-based tool,
there is no easy way to eliminate these false positives.
</p>
<p>
这条指令为一个本地变量赋值，但是这个值在后面都没有被引用到。
</p><p>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。</p><p>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。</p><p>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>Useless assignment in return statement</ShortDescription>
    <LongDescription>Useless assignment in return from {1}</LongDescription>
    <Details>
      <![CDATA[
<p>
This statement assigns to a local variable in a return statement. This assignment 
has effect. Please verify that this statement does the right thing.
</p><p>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。</p>
]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>Dead store of class literal</ShortDescription>
    <LongDescription>Dead store of {3}.class in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This instruction assigns a class literal to a variable and then never uses it.
<a href="//java.sun.com/j2se/1.5.0/compatibility.html#literal">The behavior of this differs in Java 1.4 and in Java 5.</a>
In Java 1.4 and earlier, a reference to <code>Foo.class</code> would force the static initializer
for <code>Foo</code> to be executed, if it has not been executed already.
In Java 5 and later, it does not.
</p>
<p>See Sun's <a href="//java.sun.com/j2se/1.5.0/compatibility.html#literal">article on Java SE compatibility</a>
for more details and examples, and suggestions on how to force class initialization in Java 5.
</p><p>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>Dead store of null to local variable</ShortDescription>
    <LongDescription>Dead store of null to {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code stores null into a local variable, and the stored value is not
read. This store may have been introduced to assist the garbage collector, but
as of Java SE 6.0, this is no longer needed or useful.
</p><p>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。</p>
]]>
    </Details>
  </BugPattern>

   <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>Method defines a variable that obscures a field</ShortDescription>
    <LongDescription>Method {1} defines a variable that obscures field {2.givenClass}</LongDescription>
    <Details>
<![CDATA[
<p> This method defines a local variable with the same name as a field
in this class or a superclass.  This may cause the method to
read an uninitialized value from the field, leave the field uninitialized,
or both.</p><p>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>Class defines field that masks a superclass field</ShortDescription>
    <LongDescription>Field {1.givenClass} masks field in superclass {2.class}</LongDescription>
    <Details>
<![CDATA[
<p> This class defines a field with the same name as a visible
instance field in a superclass.  This is confusing, and
may indicate an error if methods update or access one of
the fields when they wanted the other.</p>
<p>
这个类声明了一个同名字段，覆盖了父类的字段。这很容易导致：
当你想要更新这个字段的时候，却更改了另一个。
</p><p>子类中定义了和父类中同名的字段。在调用时会出错</p>
]]>
    </Details>
  </BugPattern>

    <BugPattern type="WMI_WRONG_MAP_ITERATOR">
        <ShortDescription>Inefficient use of keySet iterator instead of entrySet iterator</ShortDescription>
        <LongDescription>Method {1} makes inefficient use of keySet iterator instead of entrySet iterator</LongDescription>
        <Details>
<![CDATA[
<p> This method accesses the value of a Map entry, using a key that was retrieved from
a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the
Map.get(key) lookup.</p>
<p>
这段代码先遍历key，再根据key找value，这样做非常低效。应该直接遍历entry，从entry中得到value。
</p><p>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。</p>
]]>
        </Details>
    </BugPattern>

    <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
        <ShortDescription>Needless instantiation of class that only supplies static methods</ShortDescription>
        <LongDescription>Method {1} needlessly instantiates a class that only supplies static methods</LongDescription>
        <Details>
<![CDATA[
<p> This class allocates an object that is based on a class that only supplies static methods. This object
does not need to be created, just access the static methods directly using the class name as a qualifier.</p><p>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。</p>
]]>
        </Details>
    </BugPattern>

   <BugPattern type="REC_CATCH_EXCEPTION">
     <ShortDescription>Exception is caught when Exception is not thrown</ShortDescription>
     <LongDescription>Exception is caught when Exception is not thrown in {1}</LongDescription>
     <Details>
  <![CDATA[
  <p>
  This method uses a try-catch block that catches Exception objects, but Exception is not
  thrown within the try block, and RuntimeException is not explicitly caught.  It is a common bug pattern to
  say try { ... } catch (Exception e) { something } as a shorthand for catching a number of types of exception
  each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well,
  masking potential bugs.
  </p>
  <p>
  这想写会无意中把<code>RuntimeException</code>也捕获了，有可能导致潜在的bug。
  JVM对<code>RuntimeException</code>有统一的捕获机制，让JVM来处理它。
  </p><p>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获</p>
  ]]>
     </Details>
   </BugPattern>

    <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
     <ShortDescription>Doomed test for equality to NaN</ShortDescription>
     <LongDescription>Doomed test for equality to NaN in {1}</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This code checks to see if a floating point value is equal to the special
	Not A Number value (e.g., <code>if (x == Double.NaN)</code>). However,
	because of the special semantics of <code>NaN</code>, no value
	is equal to <code>Nan</code>, including <code>NaN</code>. Thus,
	<code>x == Double.NaN</code> always evaluates to false.

	To check to see if a value contained in <code>x</code>
	is the special Not A Number value, use 
	<code>Double.isNaN(x)</code> (or <code>Float.isNaN(x)</code> if
	<code>x</code> is floating point precision).
    </p>
	<p>
	<code>Double.NaN</code>表示未定义和不可表示的值，没有任何值和它相等。<code>x == Double.NaN</code>永远返回false。
	要判断x是不是特殊值，使用<code>Double.isNaN(x)</code>。
	</p><p>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).</p>
    ]]>
     </Details>
   </BugPattern>
    <BugPattern type="FE_FLOATING_POINT_EQUALITY">
     <ShortDescription>Test for floating point equality</ShortDescription>
     <LongDescription>Test for floating point equality in {1}</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This operation compares two floating point values for equality.
    Because floating point calculations may involve rounding,
   calculated float and double values may not be accurate.
    For values that must be precise, such as monetary values,
   consider using a fixed-precision type such as BigDecimal.
    For values that need not be precise, consider comparing for equality
    within some range, for example:
    <code>if ( Math.abs(x - y) &lt; .0000001 )</code>.
   See the Java Language Specification, section 4.2.4.
    </p><p>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较</p>
    ]]>
     </Details>
    </BugPattern>

  <BugPattern type="UM_UNNECESSARY_MATH">
    <ShortDescription>Method calls static Math class method on a constant value</ShortDescription>
    <LongDescription>Method calls static Math class method on a constant value</LongDescription>
    <Details>
<![CDATA[
<p> This method uses a static method from java.lang.Math on a constant value. This method's
result in this case, can be determined statically, and is faster and sometimes more accurate to
just use the constant. Methods detected are:
</p>
<table>
<tr>
   <th>Method</th> <th>Parameter</th>
</tr>
<tr>
   <td>abs</td> <td>-any-</td>
</tr>
<tr>
   <td>acos</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>asin</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>atan</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>atan2</td> <td>0.0</td>
</tr>
<tr>
   <td>cbrt</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>ceil</td> <td>-any-</td>
</tr>
<tr>
   <td>cos</td> <td>0.0</td>
</tr>
<tr>
   <td>cosh</td> <td>0.0</td>
</tr>
<tr>
   <td>exp</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>expm1</td> <td>0.0</td>
</tr>
<tr>
   <td>floor</td> <td>-any-</td>
</tr>
<tr>
   <td>log</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>log10</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>rint</td> <td>-any-</td>
</tr>
<tr>
   <td>round</td> <td>-any-</td>
</tr>
<tr>
   <td>sin</td> <td>0.0</td>
</tr>
<tr>
   <td>sinh</td> <td>0.0</td>
</tr>
<tr>
   <td>sqrt</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>tan</td> <td>0.0</td>
</tr>
<tr>
   <td>tanh</td> <td>0.0</td>
</tr>
<tr>
   <td>toDegrees</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>toRadians</td> <td>0.0</td>
</tr>
</table><p>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。Method Parameterabs -any-acos 0.0 or 1.0asin 0.0 or 1.0atan 0.0 or 1.0atan2 0.0 cbrt 0.0 or 1.0ceil -any-cos 0.0cosh 0.0exp 0.0 or 1.0expm1 0.0floor -any-log 0.0 or 1.0log10 0.0 or 1.0rint -any-round -any-sin 0.0sinh 0.0sqrt 0.0 or 1.0tan 0.0tanh 0.0toDegrees 0.0 or 1.0toRadians 0.0</p>
]]>
    </Details>
  </BugPattern>

    <BugPattern type="CD_CIRCULAR_DEPENDENCY">
     <ShortDescription>Test for circular dependencies among classes</ShortDescription>
     <LongDescription>Class {0} has a circular dependency with other classes</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This class has a circular dependency with other classes. This makes building these classes
    difficult, as each is dependent on the other to build correctly. Consider using interfaces
    to break the hard dependency.
    </p>
    ]]>
     </Details>
    </BugPattern>

    <BugPattern type="RI_REDUNDANT_INTERFACES">
     <ShortDescription>Class implements same interface as superclass</ShortDescription>
     <LongDescription>Class {0} implements same interface as superclass</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This class declares that it implements an interface that is also implemented by a superclass.
    This is redundant because once a superclass implements an interface, all subclasses by default also
    implement this interface. It may point out that the inheritance hierarchy has changed since
    this class was created, and consideration should be given to the ownership of
    the interface's implementation.
    </p><p>子类和父类都实现了同一个接口，这种定义是多余的。</p>
    ]]>
     </Details>
    </BugPattern>

    <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
     <ShortDescription>Class extends Struts Action class and uses instance variables</ShortDescription>
     <LongDescription>Class {0} extends Struts Action class and uses instance variables</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This class extends from a Struts Action class, and uses an instance member variable. Since only
    one instance of a struts Action class is created by the Struts framework, and used in a
    multithreaded way, this paradigm is highly discouraged and most likely problematic. Consider
    only using method local variables. Only instance fields that are written outside of a monitor
    are reported. 
    </p><p>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。</p>
    ]]>
      </Details>
    </BugPattern>

    <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
     <ShortDescription>Class extends Servlet class and uses instance variables</ShortDescription>
     <LongDescription>Class {0} extends Servlet class and uses instance variables</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This class extends from a Servlet class, and uses an instance member variable. Since only
    one instance of a Servlet class is created by the J2EE framework, and used in a
    multithreaded way, this paradigm is highly discouraged and most likely problematic. Consider
    only using method local variables.
    </p><p>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。</p>
    ]]>
      </Details>
    </BugPattern>

    <BugPattern type="PS_PUBLIC_SEMAPHORES">
     <ShortDescription>Class exposes synchronization and semaphores in its public interface</ShortDescription>
     <LongDescription>Class {0} exposes synchronization and semaphores in its public interface</LongDescription>
     <Details>
   <![CDATA[
    <p>
    This class uses synchronization along with wait(), notify() or notifyAll() on itself (the this
    reference). Client classes that use this class, may, in addition, use an instance of this class
    as a synchronizing object. Because two classes are using the same object for synchronization,
    Multithread correctness is suspect. You should not synchronize nor call semaphore methods on
    a public reference. Consider using a internal private member variable to control synchronization.
    </p>
    ]]>
      </Details>
    </BugPattern>

  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
    <ShortDescription>Result of integer multiplication cast to long</ShortDescription>
    <LongDescription>Result of integer multiplication cast to long in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code performs integer multiply and then converts the result to a long,
as in:
<code>
<pre> 
	long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; } 
</pre></code>
If the multiplication is done using long arithmetic, you can avoid
the possibility that the result will overflow. For example, you
could fix the above code to:
<code>
<pre> 
	long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; } 
</pre></code>
or 
<code>
<pre> 
	static final long MILLISECONDS_PER_DAY = 24L*3600*1000;
	long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } 
</pre></code>
</p><p>整形数做乘法运算结果转换为long值时如果采用long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; } 结果会因为超出整形的范围而出错。如果使用：long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; }或者：static final long MILLISECONDS_PER_DAY = 24L*3600*1000;long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }都可以避免此问题。</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>int value cast to float and then passed to Math.round</ShortDescription>
    <LongDescription>int value cast to float and then passed to Math.round in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code converts an int value to a float precision
floating point number and then
passing the result to the Math.round() function, which returns the int/long closest
to the argument. This operation should always be a no-op,
since the converting an integer to a float should give a number with no fractional part.
It is likely that the operation that generated the value to be passed
to Math.round was intended to be performed using 
floating point arithmetic.
</p><p>int 类型的值转换为float类型之后调用了Math.round方法</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>integral value cast to double and then passed to Math.ceil</ShortDescription>
    <LongDescription>integral value cast to double and then passed to Math.ceil in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code converts an integral value (e.g., int or long) 
to a double precision
floating point number and then
passing the result to the Math.ceil() function, which rounds a double to
the next higher integer value. This operation should always be a no-op,
since the converting an integer to a double should give a number with no fractional part.
It is likely that the operation that generated the value to be passed
to Math.ceil was intended to be performed using double precision
floating point arithmetic.
</p><p>integral的值转换为double后使用了Math.ceil方法</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>integral division result cast to double or float</ShortDescription>
    <LongDescription>integral division result cast to double or float in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code casts the result of an integral division (e.g., int or long division)
operation to double or 
float.
Doing division on integers truncates the result
to the integer value closest to zero.  The fact that the result
was cast to double suggests that this precision should have been retained.
What was probably meant was to cast one or both of the operands to
double <em>before</em> performing the division.  Here is an example:
</p>
<blockquote>
<pre>
int x = 2;
int y = 5;
// Wrong: yields result 0.0
double value1 =  x / y;

// Right: yields result 0.4
double value2 =  x / (double) y;
</pre>
</blockquote><p>整形数除法强制转换为double或者float类型。int x = 2;int y = 5;// Wrong: yields result 0.0double value1 =  x / y;// Right: yields result 0.4double value2 =  x / (double) y;</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>Store of non serializable object into HttpSession</ShortDescription>
    <LongDescription>Store of non serializable {2} into HttpSession in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code seems to be storing a non-serializable object into an HttpSession.
If this session is passivated or migrated, an error will result.
</p><p>在HttpSession对象中保存非连续的对象</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>Non serializable object written to ObjectOutput</ShortDescription>
    <LongDescription>Non serializable {2} written to ObjectOutput in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code seems to be passing a non-serializable object to the ObjectOutput.writeObject method.
If the object is, indeed, non-serializable, an error will result.
</p><p>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT">
    <ShortDescription>No previous argument for format string</ShortDescription>
    <LongDescription>No previous argument for format string argument to {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The format string specifies a relative index to request that the argument for the previous format specifier
be reused. However, there is no previous argument.
For example, 
</p>
<p><code>formatter.format("%&lt;s %s", "a", "b")</code>
</p>
<p>would throw a MissingFormatArgumentException when executed.
</p><p>格式字符串定义错误，例如：formatter.format("%<s %s", "a", "b"); 抛出MissingFormatArgumentException异常</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION">
    <ShortDescription>The type of a supplied argument doesn't match format specifier</ShortDescription>
    <LongDescription>Argument of type {3} can't be handled by format specifier {4} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
One of the arguments is uncompatible with the corresponding format string specifier.
As a result, this will generate a runtime exception when executed.
For example, <code>String.format("%d", "1")</code> will generate an exception, since
the String "1" is incompatible with the format specifier %d.
</p><p>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false</p><p>指定的格式字符串和参数类型不匹配，例如：String.format("%d", "1")</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN">
    <ShortDescription>Non-Boolean argument formatted using %b format specifier</ShortDescription>
    <LongDescription>Non-Boolean argument formatted using %b format specifier in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
An argument not of type Boolean is being formatted with a %b format specifier. This won't throw an
exception; instead, it will print true for any nonnull value, and false for null.
This feature of format strings is strange, and may not be what you intended.
</p><p>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY">
    <ShortDescription>Array formatted in useless way using format string</ShortDescription>
    <LongDescription>Argument of type {3} formatted in useless way in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
One of the arguments being formatted with a format string is an array. This will be formatted
using a fairly useless format, such as [I@304282, which doesn't actually show the contents
of the array.
Consider wrapping the array using <code>Arrays.asList(...)</code> before handling it off to a formatted.
</p>
]]>
 	</Details>
  </BugPattern>



  <BugPattern type="VA_FORMAT_STRING_ARG_MISMATCH">
    <ShortDescription>Number of format-string arguments does not correspond to number of placeholders</ShortDescription>
    <LongDescription>Format-string method {2} called with format string "{3}" wants {4} arguments but is given {5} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
A format-string method with a variable number of arguments is called,
but the number of arguments passed does not match with the number of
% placeholders in the format string.  This is probably not what the
author intended.
</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED">
    <ShortDescription>MessageFormat supplied where printf style format expected</ShortDescription>
    <LongDescription>{2} needs printf-style format but called with MessageFormat</LongDescription>
    <Details>
<![CDATA[
<p>
A method is called that expects a Java printf format string and a list of arguments.
However, the format string doesn't contain any format specifiers (e.g., %s) but
does contain message format elements (e.g., {0}).  It is likely
that the code is supplying a MessageFormat string when a printf-style format string
is required. At runtime, all of the arguments will be ignored
and the format string will be returned exactly as provided without any formatting.
</p>
</p><p>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。</p>
]]>
 	</Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED">
    <ShortDescription>More arguments are passed than are actually used in the format string</ShortDescription>
    <LongDescription>Format-string method {2} called with format string "{3}" wants {4} arguments but is given {5} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
A format-string method with a variable number of arguments is called,
but more arguments are passed than are actually used by the format string.
This won't cause a runtime exception, but the code may be silently omitting 
information that was intended to be included in the formatted string.
</p><p>使用String的format方法时有非法的参数也经过了格式化操作。</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_ILLEGAL">
    <ShortDescription>Illegal format string</ShortDescription>
    <LongDescription>Illegal format string "{3}" in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The format string is syntactically invalid, 
and a runtime exception will occur when 
this statement is executed.
</p><p>格式化String对象语句错误</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_MISSING_ARGUMENT">
    <ShortDescription>Format string references missing argument</ShortDescription>
    <LongDescription>format string "{3}" needs argument {5} but only {6} are provided in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
Not enough arguments are passed to satisfy a placeholder in the format string.
A runtime exception will occur when 
this statement is executed.
</p><p>String的format操作缺少必要的参数。</p>
]]>
 	</Details>
  </BugPattern>

  <BugPattern type="VA_FORMAT_STRING_BAD_ARGUMENT">
    <ShortDescription>Format string placeholder incompatible with passed argument</ShortDescription>
    <LongDescription>The placeholder {4} is incompatible with 
corresponding argument in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The format string placeholder is incompatible with the corresponding
argument. For example,
<code>
  System.out.println("%d\n", "hello");
</code>
<p>The %d placeholder requires a numeric argument, but a string value is
passed instead. 
A runtime exception will occur when 
this statement is executed.
</p><p>错误使用参数类型来格式化字符串</p>
]]>
 	</Details>
  </BugPattern>





  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>Primitive array passed to function expecting a variable number of object arguments</ShortDescription>
    <LongDescription>{2} passed to varargs method {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code passes a primitive array to a function that takes a variable number of object arguments.
This creates an array of length one to hold the primitive array and passes it to the function.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>Equals method should not assume anything about the type of its argument</ShortDescription>
    <LongDescription>Equals method for {0} assumes the argument is of type {0.givenClass}</LongDescription>
    <Details>
<![CDATA[
<p>
The <code>equals(Object o)</code> method shouldn't make any assumptions
about the type of <code>o</code>. It should simply return
false if <code>o</code> is not the same type as <code>this</code>.
</p><p>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>Questionable cast to abstract collection </ShortDescription>
    <LongDescription>Questionable cast from Collection to abstract class {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code casts a Collection to an abstract collection
(such as <code>List</code>, <code>Set</code>, or <code>Map</code>).
Ensure that you are guaranteed that the object is of the type
you are casting to. If all you need is to be able
to iterate through a collection, you don't need to cast it to a Set or List.
</p><p>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>Impossible cast involving primitive array</ShortDescription>
    <LongDescription>Impossible cast involving primitive array in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This cast will always throw a ClassCastException.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_CAST">
    <ShortDescription>Impossible cast</ShortDescription>
    <LongDescription>Impossible cast from {2} to {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This cast will always throw a ClassCastException.
FindBugs tracks type information from instanceof checks,
and also uses more precise information about the types
of values returned from methods and loaded from fields.
Thus, it may have more precise information that just
the declared type of a variable, and can use this to determine
that a cast will always throw an exception at runtime.

</p><p>不可能的类转换，执行时会抛出ClassCastException</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>Impossible downcast</ShortDescription>
    <LongDescription>Impossible downcast from {2} to {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This cast will always throw a ClassCastException. 
The analysis believes it knows
the precise type of the value being cast, and the attempt to
downcast it to a subtype will always fail by throwing a ClassCastException.  
</p><p>父类在向下进行类型转换时抛出ClassCastException</p><p>集合转换为数组元素时发生的类转换错误。This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:String[] getAsArray(Collection<String> c) {return (String[]) c.toArray();}This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can't really do anything else, since the Collection object has no reference to the declared generic type of the collection.The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>Impossible downcast of toArray() result</ShortDescription>
    <LongDescription>Impossible downcast of toArray() result to {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code is casting the result of calling <code>toArray()</code> on a collection
to a type more specific than <code>Object[]</code>, as in:
<pre>
String[] getAsArray(Collection&lt;String&gt; c) {
  return (String[]) c.toArray();
  }
</pre>
<p>This will usually fail by throwing a ClassCastException. The <code>toArray()</code>
of almost all collections return an <code>Object[]</code>. They can't really do anything else,
since the Collection object has no reference to the declared generic type of the collection.
<p>The correct way to do get an array of a specific type from a collection is to use
  <code>c.toArray(new String[]);</code>
  or <code>c.toArray(new String[c.size()]);</code> (the latter is slightly more efficient).
<p>There is one common/known exception exception to this. The <code>toArray()</code>
method of lists returned by <code>Arrays.asList(...)</code> will return a covariantly
typed array. For example, <code>Arrays.asArray(new String[] { "a" }).toArray()</code>
will return a <code>String []</code>. FindBugs attempts to detect and suppress
such cases, but may miss some.
</p><p>集合转换为数组元素时发生的类转换错误。This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:String[] getAsArray(Collection<String> c) {return (String[]) c.toArray();}This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can't really do anything else, since the Collection object has no reference to the declared generic type of the collection.The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>A known null value is checked to see if it is an instance of {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This instanceof test will always return false, since the value being checked is guaranteed to be null.
Although this is safe, make sure it isn't
an indication of some misunderstanding or some other logic error.
</p><p>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true"> <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>A known null value is checked to see if it is an instance of a type</ShortDescription>
    <LongDescription>A known null value is checked to see if it is an instance of {2} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This instanceof test will always return false, since the value being checked is guaranteed to be null.
Although this is safe, make sure it isn't
an indication of some misunderstanding or some other logic error.
</p><p>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof will always return false</ShortDescription>
    <LongDescription>instanceof will always return false in {1}, since a {2} can't be a {3}</LongDescription>
    <Details>
<![CDATA[
<p>
This instanceof test will always return false. Although this is safe, make sure it isn't
an indication of some misunderstanding or some other logic error.
</p><p>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="BC_VACUOUS_INSTANCEOF">
    <ShortDescription>instanceof will always return true</ShortDescription>
    <LongDescription>instanceof will always return true in {1}, since all {2} are instances of {3}</LongDescription>
    <Details>
<![CDATA[
<p>
This instanceof test will always return true (unless the value being tested is null). 
Although this is safe, make sure it isn't
an indication of some misunderstanding or some other logic error.
If you really want to test the value for being null, perhaps it would be clearer to do
better to do a null test rather than an instanceof test.
</p>
这个instanceof将永远返回true（除非对象的值为null），这样写让人不易理解你的目的。
<p>
</p><p>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>Unchecked/unconfirmed cast</ShortDescription>
    <LongDescription>Unchecked/unconfirmed cast from {2} to {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This cast is unchecked, and not all instances of the type casted from can be cast to
the type it is being cast to. Ensure that your program logic ensures that this
cast will not fail.
</p><p>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>Questionable cast to concrete collection</ShortDescription>
    <LongDescription>Questionable cast from {2} to {3} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
This code casts an abstract collection (such as a Collection, List, or Set)
to a specific concrete implementation (such as an ArrayList or HashSet).
This might not be correct, and it may make your code fragile, since
it makes it harder to switch to other concrete implementations at a future
point. Unless you have a particular reason to do so, just use the abstract
collection class.
</p><p>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>"." used for regular expression</ShortDescription>
    <LongDescription>"." used for regular expression in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
A String function is being invoked and "." is being passed
to a parameter that takes a regular expression as an argument. Is this what you intended?
For example
s.replaceAll(".", "/") will return a String in which <em>every</em>
character has been replaced by a / character,
and s.split(".") <em>always</em> returns a zero length array of String.
</p>
String的split方法接受的参数是一个正则表达式，如果在参数使用正则表达式的元字符
（".","$","^","*","()","[]","{}"等），则需要转义：在元字符前面加上"\\"转义符。
<p>

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>Invalid syntax for regular expression</ShortDescription>
    <LongDescription>Invalid syntax for regular expression in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code here uses a regular expression that is invalid according to the syntax
for regular expressions. This statement will throw a PatternSyntaxException when
executed.
</p><p>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
    <ShortDescription>File.separator used for regular expression</ShortDescription>
    <LongDescription>File.separator used for regular expression in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code here uses <code>File.separator</code> 
where a regular expression is required. This will fail on Windows
platforms, where the <code>File.separator</code> is a backslash, which is interpreted in a
regular expression as an escape character. Amoung other options, you can just use
<code>File.separatorChar=='\\' ? "\\\\" : File.separator</code> instead of
<code>File.separator</code>

</p><p>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\’而应该使用'\\'</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>Overwritten increment</ShortDescription>
    <LongDescription>Overwritten increment in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code performs an increment operation (e.g., <code>i++</code>) and then
immediately overwrites it. For example, <code>i = i++</code> immediately
overwrites the incremented value with the original value.
</p><p>覆写增量增加错误i = i++</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>Unsigned right shift cast to short/byte</ShortDescription>
    <LongDescription>Unsigned right shift cast to short/byte in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code performs an unsigned right shift, whose result is then
cast to a short or byte, which discards the upper bits of the result.
Since the upper bits are discarded, there may be no difference between
a signed and unsigned right shift (depending upon the size of the shift).
</p><p>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>32 bit int shifted by an amount not in the range 0..31</ShortDescription>
    <LongDescription>32 bit int shifted by {2} bits in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code performs shift of a 32 bit int by a constant amount outside
the range 0..31.
The effect of this is to use the lower 5 bits of the integer
value to decide how much to shift by (e.g., shifting by 40 bits is the same as shifting by 8 bits,
and shifting by 32 bits is the same as shifting by zero bits). This probably isn't want was expected,
and it at least confusing.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>Integer multiply of result of integer remainder</ShortDescription>
    <LongDescription>Integer multiple of result of integer remainder in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code multiplies the result of an integer remaining by an integer constant.
Be sure you don't have your operator precedence confused. For example
i % 60 * 1000 is (i % 60) * 1000, not i % (60 * 1000).
</p><p>和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000)</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
    <ShortDescription>Invocation of hashCode on an array</ShortDescription>
    <LongDescription>Invocation of hashCode on array in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code invokes hashCode on an array. Calling hashCode on
an array returns the same value as System.identityHashCode, and ingores
the contents and length of the array. If you need a hashCode that
depends on the contents of an array <code>a</code>, 
use <code>java.util.Arrays.hashCode(a)</code>.

</p><p>数组直接使用hashCode方法来返回哈希码。int [] a1 = new int[]{1,2,3,4};System.out.println(a1.hashCode());System.out.println(java.util.Arrays.hashCode(a1));</p>
]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
    <ShortDescription>Invocation of toString on an array</ShortDescription>
    <LongDescription>Invocation of toString on {2.givenClass} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code invokes toString on an array, which will generate a fairly useless result
such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable
String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.
</p><p>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>Invocation of toString on an array</ShortDescription>
    <LongDescription>Invocation of toString on an array in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code invokes toString on an (anonymous) array.  Calling toString on an array generates a fairly useless result
such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable
String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.
</p><p>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：String[] a = { "a" };System.out.println(a.toString());//正确的使用为System.out.println(Arrays.toString(a));</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
    <ShortDescription>Computation of average could overflow</ShortDescription>
    <LongDescription>Computation of average could overflow in {1}</LongDescription>
    <Details>
<![CDATA[
<p>The code computes the average of two integers using either division or signed right shift,
and then uses the result as the index of an array.
If the values being averaged are very large, this can overflow (resulting in the computation
of a negative average).  Assuming that the result is intended to be nonnegative, you 
can use an unsigned right shift instead. In other words, rather that using <code>(low+high)/2</code>,
use <code>(low+high) &gt;&gt;&gt; 1</code>
</p>
<p>This bug exists in many earlier implementations of binary search and merge sort.
Martin Buchholz <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541">found and fixed it</a>
in the JDK libraries, and Joshua Bloch
<a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">widely
publicized the bug pattern</a>.
</p>
<p>
求平均值的过程中可能会导致溢出。避免使用<code>(low+high)/2</code>，而使用<code>(low+high) &gt;&gt;&gt; 1</code>替代。
</p><p>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x & 1 == 1, or x % 2 != 0来代替</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>Check for oddness that won't work for negative numbers </ShortDescription>
    <LongDescription>Check for oddness that won't work for negative numbers in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
The code uses x % 2 == 1 to check to see if a value is odd, but this won't work
for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check
for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.
</p>
<p>
这段代码使用x % 2 == 1来判断x是否是奇数，但如果x是负数，判断将无效。
例如：(-5) % 2 == -1。建议改写成x % 2 != 0。
</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>Code contains a hard coded reference to an absolute pathname</ShortDescription>
    <LongDescription>Hard coded reference to an absolute pathname in {1}</LongDescription>
    <Details>
<![CDATA[
<p>This code constructs a File object using a hard coded to an absolute pathname
(e.g., <code>new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");</code>
</p><p>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>Bad constant value for month</ShortDescription>
    <LongDescription>{1} passes a bad month value of {2} to {3}</LongDescription>
    <Details>
<![CDATA[
<p>
This code passes a constant month
value outside the expected range of 0..11 to a method.
</p><p>hashNext方法调用next方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>Invocation of substring(0), which returns the original value</ShortDescription>
    <LongDescription>{1} invokes substring(0), which returns the original value</LongDescription>
    <Details>
<![CDATA[
<p>
This code invokes substring(0) on a String, which returns the original value.
</p><p>此代码调用了subString(0)方法，它将返回原来的值。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>hasNext method invokes next</ShortDescription>
    <LongDescription>{1} invokes {3}</LongDescription>
    <Details>
<![CDATA[
<p>
The hasNext() method invokes the next() method. This is almost certainly wrong,
since the hasNext() method is not supposed to change the state of the iterator,
and the next method is supposed to change the state of the iterator.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
   <ShortDescription>Method calls Thread.sleep() with a lock held</ShortDescription>
   <LongDescription>{1} calls Thread.sleep() with a lock held</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method calls Thread.sleep() with a lock held.  This may result
      in very poor performance and scalability, or a deadlock, since other threads may
      be waiting to acquire the lock.  It is a much better idea to call
      wait() on the lock, which releases the lock and allows other threads
      to run.
      </p><p>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="DB_DUPLICATE_BRANCHES">
   <ShortDescription>Method uses the same code for two branches</ShortDescription>
   <LongDescription>Method {1} uses the same code for two branches</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method uses the same code to implement two branches of a conditional branch.
	Check to ensure that this isn't a coding mistake.
      </p><p>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
   <ShortDescription>Method uses the same code for two switch clauses</ShortDescription>
   <LongDescription>Method {1} uses the same code for two switch clauses</LongDescription>
   <Details>
      <![CDATA[
      <p>
      This method uses the same code to implement two clauses of a switch statement.
	This could be a case of duplicate code, but it might also indicate
	a coding mistake.
      </p><p>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。</p>
      ]]>
   </Details>
  </BugPattern>

  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>Method accesses a private member variable of owning class</ShortDescription>
    <LongDescription>Method {1} accesses to a private member variable of owning class</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method of an inner class reads from or writes to a private member variable of the owning class,
      or calls a private method of the owning class. The compiler must generate a special method to access this
      private member, causing this to be less efficient. Relaxing the protection of the member variable or method
      will allow the compiler to treat this as a normal access.
      </p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>Method directly allocates a specific implementation of xml interfaces</ShortDescription>
    <LongDescription>Method {1} directly allocates a specific implementation of xml interfaces</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method allocates a specific implementation of an xml interface. It is preferable to use
      the supplied factory classes to create these objects so that the implementation can be
      changed at runtime. See
      </p>
      <ul>
         <li>javax.xml.parsers.DocumentBuilderFactory</li>
         <li>javax.xml.parsers.SAXParserFactory</li>
         <li>javax.xml.transform.TransformerFactory</li>
         <li>org.w3c.dom.Document.create<i>XXXX</i></li>
      </ul>
      <p>for details.</p><p>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：javax.xml.parsers.DocumentBuilderFactoryjavax.xml.parsers.SAXParserFactoryjavax.xml.transform.TransformerFactoryorg.w3c.dom.Document.createXXXX</p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>Method superfluously delegates to parent class method</ShortDescription>
    <LongDescription>Method {1} superfluously delegates to parent class method</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This derived method merely calls the same superclass method passing in the exact parameters
      received. This method can be removed, as it provides no additional value.
      </p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>Abstract Method is already defined in implemented interface</ShortDescription>
    <LongDescription>Abstract Method {1} is already defined in implemented interface</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This abstract method is already defined in an interface that is implemented by this abstract 
      class. This method can be removed, as it provides no additional value.
      </p>
      ]]>
    </Details>
  </BugPattern>
  
    <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>Class is final but declares protected field</ShortDescription>
    <LongDescription>Class {0} is final but declares protected field {1}</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This class is declared to be final, but declares fields to be protected. Since the class
      is final, it can not be derived from, and the use of protected is confusing. The access
      modifier for the field should be changed to private or public to represent the true
      use for the field.
      </p><p>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。</p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>Method assigns boolean literal in boolean expression</ShortDescription>
    <LongDescription>Method {1} assigns boolean literal in boolean expression</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This method assigns a literal boolean value (true or false) to a boolean variable inside
      an if or while expression. Most probably this was supposed to be a boolean comparison using 
      ==, not an assignment using =.
      </p><p>再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>Class makes reference to unresolvable class or method</ShortDescription>
    <LongDescription>Unresolvable reference to {1} by {0}</LongDescription>
    <Details>
      <![CDATA[
      <p>
      This class makes a reference to a class or method that can not be
	resolved using against the libraries it is being analyzed with.
      </p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>Unchecked type in generic call</ShortDescription>
    <LongDescription>Unchecked argument of type Object provided where type {3.givenClass} is expected in {1}</LongDescription>
    <Details>
     <![CDATA[
     <p> This call to a generic collection method passes an argument
	while compile type Object where a specific type from
	the generic type parameters is expected.
	Thus, neither the standard Java type system nor static analysis
	can provide useful information on whether the
	object being passed as a parameter is of an appropriate type.
	</p><p>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.</p>
     ]]>
    </Details>
  </BugPattern>

  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>No relationship between generic parameter and method argument</ShortDescription>
    <LongDescription>{2.givenClass} is incompatible with expected argument type {3.givenClass} in {1}</LongDescription>
    <Details>
     <![CDATA[
     <p> This call to a generic collection method contains an argument
     with an incompatible class from that of the collection's parameter
	(i.e., the type of the argument is neither a supertype nor a subtype 
		of the corresponding generic type argument).
     Therefore, it is unlikely that the collection contains any objects 
	that are equal to the method argument used here.
	Most likely, the wrong value is being passed to the method.</p>
	<p>In general, instances of two unrelated classes are not equal. 
	For example, if the <code>Foo</code> and <code>Bar</code> classes
	are not related by subtyping, then an instance of <code>Foo</code>
		should not be equal to an instance of <code>Bar</code>.
	Among other issues, doing so will likely result in an equals method
	that is not symmetrical. For example, if you define the <code>Foo</code> class
	so that a <code>Foo</code> can be equal to a <code>String</code>,
	your equals method isn't symmetrical since a <code>String</code> can only be equal
	to a <code>String</code>.
	</p>
	<p>In rare cases, people do define nonsymmetrical equals methods and still manage to make 
	their code work. Although none of the APIs document or guarantee it, it is typically
	the case that if you check if a <code>Collection&lt;String&gt;</code> contains
	a <code>Foo</code>, the equals method of argument (e.g., the equals method of the 
	<code>Foo</code> class) used to perform the equality checks.
	</p><p>This call to a generic collection method contains an argument with an incompatible class from that of the collection's parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn't symmetrical since a String can only be equal to a String.In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<String> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.</p>
     ]]>
    </Details>
  </BugPattern>




  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>Collections should not contain themselves</ShortDescription>
    <LongDescription>Collections should not contain themselves in call to {2.givenClass}</LongDescription>
    <Details>
     <![CDATA[
     <p> This call to a generic collection's method would only make sense if a collection contained 
itself (e.g., if <code>s.contains(s)</code> were true). This is unlikely to be true and would cause
problems if it were true (such as the computation of the hash code resulting in infinite recursion).
It is likely that the wrong value is being passed as a parameter.
	</p><p>集合没有包含他们自己本身。</p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>Vacuous call to collections</ShortDescription>
    <LongDescription>For any collection c, calling c.{2.name}(c) doesn't make sense </LongDescription>
    <Details>
     <![CDATA[
     <p> This call doesn't make sense. For any collection <code>c</code>, calling <code>c.containsAll(c)</code> should
always be true, and <code>c.retainAll(c)</code> should have no effect.
	</p><p>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。</p>
     ]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>Don't use removeAll to clear a collection</ShortDescription>
    <LongDescription>removeAll used to clear a collection in {1}</LongDescription>
    <Details>
     <![CDATA[
     <p> If you want to remove all elements from a collection <code>c</code>, use <code>c.clear</code>,
not <code>c.removeAll(c)</code>. Calling  <code>c.removeAll(c)</code> to clear a collection
is less clear, susceptible to errors from typos, less efficient and 
for some collections, might throw a <code>ConcurrentModificationException</code>.
	</p><p>不要用removeAll方法去clear一个集合</p>
     ]]>
    </Details>
  </BugPattern>

<BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
<ShortDescription>Static Calendar</ShortDescription>
<LongDescription>Found static field of type java.util.Calendar in {1}</LongDescription>
<Details>
<![CDATA[
<p>Even though the JavaDoc does not contain a hint about it, Calendars are inherently unsafe for multihtreaded use. 
Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the
application. Under 1.4 problems seem to surface less often than under Java 5 where you will probably see
random ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions in sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().</p>
<p>You may also experience serialization problems.</p>
<p>Using an instance field is recommended.</p>
<p>For more information on this see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p><p>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。</p>
]]>
</Details>
</BugPattern>

<BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
<ShortDescription>Call to static Calendar</ShortDescription>
<LongDescription>Call to method of static java.util.Calendar in {1}</LongDescription>
<Details>
<![CDATA[
<p>Even though the JavaDoc does not contain a hint about it, Calendars are inherently unsafe for multihtreaded use. 
The detector has found a call to an instance of Calendar that has been obtained via a static
field. This looks suspicous.</p>
<p>For more information on this see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p><p>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。Calendar rightNow = Calendar.getInstance();</p>
]]>
</Details>
</BugPattern>


<BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
<ShortDescription>Static DateFormat</ShortDescription>
<LongDescription>Found static field of type java.text.DateFormat in {1}</LongDescription>
<Details>
<![CDATA[
<p>As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use. 
Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the
application.</p>
<p>You may also experience serialization problems.</p>
<p>Using an instance field is recommended.</p>
<p>For more information on this see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p><p>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。</p>
]]>
</Details>
</BugPattern>

<BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
<ShortDescription>Call to static DateFormat</ShortDescription>
<LongDescription>Call to method of static java.text.DateFormat in {1}</LongDescription>
<Details>
<![CDATA[
<p>As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use. 
The detector has found a call to an instance of DateFormat that has been obtained via a static
field. This looks suspicous.</p>
<p>For more information on this see <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p>
<p>
你的代码中使用了一个静态的DateFormat实例，DateFomat不是线程安全的，因此建议不要定义为静态成员。
</p><p>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。myString = DateFormat.getDateInstance().format(myDate);</p>
]]>
</Details>
</BugPattern>

  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>Value annotated as carrying a type qualifier used where a value that must not carry that qualifier is required</ShortDescription>
    <LongDescription>Value annotated as carrying type qualifier {2} used where a value that must not carry that qualifier is required</LongDescription>
    <Details>
      <![CDATA[
        <p>
        A value specified as carrying a type qualifier annotation is
        consumed in a location or locations requiring that the value not
        carry that annotation.
        </p>
        
        <p>
        More precisely, a value annotated with a type qualifier specifying when=ALWAYS
        is guaranteed to reach a use or uses where the same type qualifier specifies when=NEVER.
        </p>
        
        <p>
        For example, say that @NonNegative is a nickname for
        the type qualifier annotation @Negative(when=When.NEVER).
        The following code will generate this warning because
        the return statement requires a @NonNegative value,
        but receives one that is marked as @Negative.   
        </p>
        <blockquote>
<pre>
public @NonNegative Integer example(@Negative Integer value) {
    return value;
}
</pre>
        </blockquote>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>Value annotated as never carrying a type qualifier used where value carrying that qualifier is required</ShortDescription>
    <LongDescription>Value annotated as never carrying type qualifier {2} used where value carrying that qualifier is required</LongDescription>
    <Details>
      <![CDATA[
        <p>
        A value specified as not carrying a type qualifier annotation is guaranteed
        to be consumed in a location or locations requiring that the value does
        carry that annotation.
        </p>
        
        <p>
        More precisely, a value annotated with a type qualifier specifying when=NEVER
        is guaranteed to reach a use or uses where the same type qualifier specifies when=ALWAYS.
        </p>

        <p>
        TODO: example
        </p>        
      ]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>Value that might not carry a type qualifier is always used in a way requires that type qualifier</ShortDescription>
    <LongDescription>Value that might not carry the {2} annotation is always used in a way that requires that type qualifier</LongDescription>
    <Details>
      <![CDATA[
      <p>
      A value that is annotated as possibility not being an instance of
	the values denoted by the type qualifier, and the value is guaranteed to be used
	in a way that requires values denoted by that type qualifier.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>Value that might carry a type qualifier is always used in a way prohibits it from having that type qualifier</ShortDescription>
    <LongDescription>Value that might carry the {2} annotation is always used in a way that prohibits it from having that type qualifier</LongDescription>
    <Details>
      <![CDATA[
      <p>
      A value that is annotated as possibility being an instance of
	the values denoted by the type qualifier, and the value is guaranteed to be used
	in a way that prohibits values denoted by that type qualifier.
      </p>
      ]]>
    </Details>
  </BugPattern>
  
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>Explicit annotation inconsistent with use</ShortDescription>
    <LongDescription>Value is required never be {2}, but is explicitly annotated as unknown with regards to {2}</LongDescription>
    <Details>
      <![CDATA[
      <p>
      A value is used in a way that requires it to be never be a value denoted by a type qualifier, but
	there is an explicit annotation stating that it is not known where the value is prohibited from having that type qualifier.
	Either the usage or the annotation is incorrect.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>Explicit annotation inconsistent with use</ShortDescription>
    <LongDescription>Value is required to always be {2}, but is explicitly annotated as unknown with regards to {2}</LongDescription>
    <Details>
      <![CDATA[
      <p>
      A value is used in a way that requires it to be always be a value denoted by a type qualifier, but
	there is an explicit annotation stating that it is not known where the value is required to have that type qualifier.
	Either the usage or the annotation is incorrect.
      </p>
      ]]>
    </Details>
  </BugPattern>




  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>Doomed attempt to append to an object output stream</ShortDescription>
    <LongDescription>Doomed attempt to append to an object output stream in {1}</LongDescription>
    <Details>
      <![CDATA[
      <p>
     This code opens a file in append mode and then wraps the result in an object output stream. 
     This won't allow you to append to an existing object output stream stored in a file. If you want to be
     able to append to an object output stream, you need to keep the object output stream open.
      </p>
      <p>The only situation in which opening a file in append mode and the writing an object output stream
      could work is if on reading the file you plan to open it in random access mode and seek to the byte offset
      where the append started.
      </p> 
      
      <p>
      TODO: example.
      </p><p>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>Sychronization on getClass rather than class literal</ShortDescription>
    <LongDescription>Sychronization on getClass rather than class literal in {1}</LongDescription>
    <Details>
      <![CDATA[
      <p>
     This instance method synchronizes on <code>this.getClass()</code>. If this class is subclassed,
     subclasses will synchronize on the class object for the subclass, which isn't likely what was intended.
     For example, consider this code from java.awt.Label:
     <pre>
     private static final String base = "label";
     private static int nameCounter = 0;
     String constructComponentName() {
        synchronized (getClass()) {
            return base + nameCounter++;
        }
     }
     </pre></p>
     <p>Subclasses of <code>Label</code> won't synchronize on the same subclass, giving rise to a datarace.
     Instead, this code should be synchronizing on <code>Label.class</code>
      <pre>
     private static final String base = "label";
     private static int nameCounter = 0;
     String constructComponentName() {
        synchronized (Label.class) {
            return base + nameCounter++;
        }
     }
     </pre></p>
      <p>Bug pattern contributed by Jason Mehrens</p><p>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：private static final String base = "label";private static int nameCounter = 0;String constructComponentName() {synchronized (getClass()) {return base + nameCounter++;}}Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：private static final String base = "label";private static int nameCounter = 0;String constructComponentName() {synchronized (Label.class) {return base + nameCounter++;}}</p>
      ]]>
    </Details>
  </BugPattern>

  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
	  <ShortDescription>Method may fail to clean up stream or resource</ShortDescription>
	  <LongDescription>Method {1} may fail to clean up {2}</LongDescription>
	  <Details>
		  <![CDATA[
		  <p>
		  This method may fail to clean up (close, dispose of) a stream,
		  database object, or other
		  resource requiring an explicit cleanup operation.
		  </p>
		  
		  <p>
		  In general, if a method opens a stream or other resource,
		  the method should use a try/finally block to ensure that
		  the stream or resource is cleaned up before the method
		  returns.
		  </p>
		  
		  <p>
		  This bug pattern is essentially the same as the
		  OS_OPEN_STREAM and ODR_OPEN_DATABASE_RESOURCE
		  bug patterns, but is based on a different
		  (and hopefully better) static analysis technique.
		  We are interested is getting feedback about the
		  usefulness of this bug pattern.
		  To send feedback, either:
		  </p>
		  <ul>
			<li>send email to findbugs@cs.umd.edu</li>
			<li>file a bug report: <a href="http://findbugs.sourceforge.net/reportingBugs.html">http://findbugs.sourceforge.net/reportingBugs.html</a></li>
		  </ul>
		  
		  <p>
		  In particular,
		  the false-positive suppression heuristics for this
		  bug pattern have not been extensively tuned, so
		  reports about false positives are helpful to us.
		  </p>
		  
		  <p>
		  See Weimer and Necula, <i>Finding and Preventing Run-Time Error Handling Mistakes</i>, for
		  a description of the analysis technique.
		  </p><p>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>
		  ]]>
	  </Details>
  </BugPattern>

  <BugPattern type="FB_UNEXPECTED_WARNING">
	  <ShortDescription>Unexpected/undesired warning from FindBugs</ShortDescription>
	  <LongDescription>Unexpected/undesired {2} FindBugs warning in {1}</LongDescription>
	  <Details>
		  <![CDATA[
		  <p>FindBugs generated a warning that, according to a @NoWarning annotated,
			is unexpected or undesired</p>
		  ]]>
	  </Details>
  </BugPattern>
  
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
	  <ShortDescription>Missing expected or desired warning from FindBugs</ShortDescription>
	  <LongDescription>Missing expected or desired {2} FindBugs warning in {1}</LongDescription>
	  <Details>
		  <![CDATA[
		  <p>FindBugs didn't generate generated a warning that, according to a @ExpectedWarning annotated,
			is expected or desired</p>
		  ]]>
	  </Details>
  </BugPattern>
  
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
	  <ShortDescription>Return value of putIfAbsent ignored, value passed to putIfAbsent reused</ShortDescription>
	  <LongDescription>Return value of putIfAbsent is ignored, but {4} is reused in {1}</LongDescription>
	  <Details>
		  <![CDATA[
		The <code>putIfAbsent</code> method is typically used to ensure that a 
		single value is associated with a given key (the first value for which put 
		if absent succeeds).  
		If you ignore the return value and retain a reference to the value passed in, 
		you run the risk of retaining a value that is not the one that is associated with the key in the map.  
		If it matters which one you use and you use the one that isn't stored in the map,
		your program will behave incorrectly.
		  ]]>
	  </Details>
  </BugPattern>
  
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
	  <ShortDescription>Potential lost logger changes due to weak reference in OpenJDK</ShortDescription>
	  <LongDescription>Changes to logger could be lost in {1}</LongDescription>
	  <Details>
		  <![CDATA[
<p>OpenJDK introduces a potential incompatibility.
 In particular, the java.util.logging.Logger behavior has
  changed. Instead of using strong references, it now uses weak references
  internally. That's a reasonable change, but unfortunately some code relies on
  the old behavior - when changing logger configuration, it simply drops the
  logger reference. That means that the garbage collector is free to reclaim
  that memory, which means that the logger configuration is lost. For example,
consider:
</p>

<p><pre>public static void initLogging() throws Exception {
 Logger logger = Logger.getLogger("edu.umd.cs");
 logger.addHandler(new FileHandler()); // call to change logger configuration
 logger.setUseParentHandlers(false); // another call to change logger configuration
}</pre></p>

<p>The logger reference is lost at the end of the method (it doesn't
escape the method), so if you have a garbage collection cycle just
after the call to initLogging, the logger configuration is lost
(because Logger only keeps weak references).</p>

<p><pre>public static void main(String[] args) throws Exception {
 initLogging(); // adds a file handler to the logger
 System.gc(); // logger configuration lost
 Logger.getLogger("edu.umd.cs").info("Some message"); // this isn't logged to the file as expected
}</pre></p>
<p><em>Ulf Ochsenfahrt and Eric Fellheimer</em></p><p>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。�logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：public static void initLogging() throws Exception {Logger logger = Logger.getLogger("edu.umd.cs");logger.addHandler(new FileHandler()); // call to change logger configurationlogger.setUseParentHandlers(false); // another call to change logger configuration}该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。public static void main(String[] args) throws Exception {initLogging(); // adds a file handler to the loggerSystem.gc(); // logger configuration lostLogger.getLogger("edu.umd.cs").info("Some message"); // this isn't logged to the file as expected}</p>
		  ]]>
	  </Details>
  </BugPattern>
  
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->

  <BugCode abbrev="FS" >Format string problem</BugCode>
  <BugCode abbrev="SKIPPED" >Analysis skipped</BugCode>
  <BugCode abbrev="IL" >Infinite Loop</BugCode>
  <BugCode abbrev="VO" >Use of volatile</BugCode>
  <BugCode abbrev="UI" >Unsafe inheritance</BugCode>
  <BugCode abbrev="FL" >Use of floating point precision</BugCode>
  <BugCode abbrev="TEST" >Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE" >Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN" >Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="AT" >Possible atomicity violation</BugCode>
  <BugCode abbrev="FI" >Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES" >Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML" >Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG" >Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO" >Input/Output problem</BugCode>
  <BugCode abbrev="IC" >Initialization circularity</BugCode>
  <BugCode abbrev="SI" >Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF" >Mutable servlet field</BugCode>
  <BugCode abbrev="IS" >Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq" >Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co" >Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE" >Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM" >API misuse</BugCode>
  <BugCode abbrev="Dm" >Dubious method used</BugCode>
  <BugCode abbrev="Bx" >Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR" >Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR" >Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN" >Naked notify</BugCode>
  <BugCode abbrev="UW" >Unconditional wait</BugCode>
  <BugCode abbrev="SP" >Method spins on field</BugCode>
  <BugCode abbrev="DC" >Possible double check of field</BugCode>
  <BugCode abbrev="Wa" >Wait not in loop</BugCode>
  <BugCode abbrev="No" >Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE" >Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru" >Method invokes run()</BugCode>
  <BugCode abbrev="It" >Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI" >Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se" >Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS" >Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS" >Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC" >Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS" >Mutable static field</BugCode>
  <BugCode abbrev="EI" >Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm" >Confusing method name</BugCode>
  <BugCode abbrev="SS" >Unread field should be static</BugCode>
  <BugCode abbrev="UuF" >Unused field</BugCode>
  <BugCode abbrev="UrF" >Unread field</BugCode>
  <BugCode abbrev="UwF" >Unwritten field</BugCode>
  <BugCode abbrev="SIC" >Inner class could be made static</BugCode>
  <BugCode abbrev="TLW" >Wait with two locks held</BugCode>
  <BugCode abbrev="RV" >Bad use of return value from method</BugCode>
  <BugCode abbrev="LG" >Logger problem</BugCode>
  <BugCode abbrev="IA" >Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC" >Huge String constants</BugCode>
  <BugCode abbrev="HRS" >HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="XSS" >Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP" >Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">Bogus random warning</BugCode>
  <BugCode abbrev="RpC" >Repeated conditional test</BugCode>
  <BugCode abbrev="OS">Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA" >Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">Useless control flow</BugCode>
  <BugCode abbrev="RCN">Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">Comparing incompatable types for equality</BugCode>
  <BugCode abbrev="MWN">Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">Useless self-operation</BugCode>
  <BugCode abbrev="INT">Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">Private method is never called</BugCode>
  <BugCode abbrev="UMAC">Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="ITA">Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing coding rules</BugCode>
  <BugCode abbrev="IJU">Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">Switch case falls through</BugCode>
  <BugCode abbrev="SIO">Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">Use Object Equals</BugCode>
  <BugCode abbrev="STI">Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">Dead local store</BugCode>
  <BugCode abbrev="IP">Ignored parameter</BugCode>
  <BugCode abbrev="MF">Masked Field</BugCode>
  <BugCode abbrev="WMI">Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">Instantiated Static Class</BugCode>
  <BugCode abbrev="REC">RuntimeException capture</BugCode>
  <BugCode abbrev="FE">Test for floating point equality</BugCode>
  <BugCode abbrev="UM">Unnecessary Math on constants</BugCode>
  <BugCode abbrev="CD">Circular Dependencies</BugCode>
  <BugCode abbrev="RI">Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">Bad shift</BugCode>
  <BugCode abbrev="ICAST">Casting from integer values</BugCode>
  <BugCode abbrev="RE">Regular expressions</BugCode>
  <BugCode abbrev="SQL">Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">Questionable for loops</BugCode>
  <BugCode abbrev="VA">Var arg problems</BugCode>
  <BugCode abbrev="BC">Bad casts of object references</BugCode>
  <BugCode abbrev="IM">Questionable integer math</BugCode>
  <BugCode abbrev="ST">Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">Warning inspired by Josh Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">J2EE error</BugCode>
  <BugCode abbrev="DB">Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">Version compatibility issue</BugCode>
  <BugCode abbrev="DP">Use doPrivileged</BugCode>
  <BugCode abbrev="GC">Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">FindBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">Potential deadlock due to unintended locking on shared objects</BugCode>
  </MessageCollection>
